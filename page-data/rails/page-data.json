{"componentChunkName":"component---src-templates-note-template-tsx","path":"/rails/","result":{"data":{"markdownRemark":{"html":"<h2>Active Record</h2>\n<ul>\n<li>Scope vs class method, similar, pick one.</li>\n</ul>\n<h3>Belongs to</h3>\n<ul>\n<li>\n<p><code>Person.all.joins(:role)</code> does a sql inner join on roles by the foreign key.</p>\n</li>\n<li>\n<p>The join table is available for the query but not returned to the results.</p>\n</li>\n<li>\n<p><code>.where(roles: {billable: true})</code> filters by the field billable.</p>\n</li>\n</ul>\n<p>example class method to support where clause:</p>\n<pre><code class=\"language-ruby\">class Role &#x3C; ActiveRecord::Base\n  def self.billable\n    where(billable: true)\n  end\nend\n</code></pre>\n<ul>\n<li><code>Person.all.joins(:role).merge(Role.billable)</code> same as earlier using class method.</li>\n</ul>\n<h3>Has many</h3>\n<ul>\n<li>\n<p><code>Location.joins(people: :role)</code> inner join on people and roles, like on the fly has many through</p>\n</li>\n<li>\n<p><code>distinct</code> selects unique. order by has to be in the select and has to be distinct.</p>\n</li>\n<li>\n<p><code>Location.from(Location.billable, :locations)</code> wraps in a subquery.</p>\n</li>\n</ul>\n<h3>N+1</h3>\n<ul>\n<li>Typically database client issue.</li>\n<li><a href=\"https://github.com/MiniProfiler/rack-mini-profiler\">https://github.com/MiniProfiler/rack-mini-profiler</a></li>\n<li><a href=\"https://github.com/flyerhzm/bullet\">https://github.com/flyerhzm/bullet</a></li>\n<li>gem called bullet catches most, not all</li>\n<li><a href=\"https://github.com/evrone/quiet_assets\">https://github.com/evrone/quiet_assets</a> cuts noise down</li>\n<li>logging is useful</li>\n</ul>\n<p><code>tail -f log/development.log | grep SELECT</code> view db selects</p>\n<p><code>includes</code> is eagar loading which can decrease n+1, if you know you need relations.</p>\n<ul>\n<li>\n<p>Polymorphic has to use <code>preload</code> polymorphic associations. Won't work if you need to use the join table in the query.</p>\n</li>\n<li>\n<p>Includes works for non-polymorphic and if you have to do something with the stuff.</p>\n</li>\n<li>\n<p>can introduce bloat</p>\n</li>\n</ul>\n<h2>Autoloading and reloading constants</h2>\n<p><a href=\"https://guides.rubyonrails.org/v5.2/autoloading_and_reloading_constants.html\">https://guides.rubyonrails.org/v5.2/autoloading_and_reloading_constants.html</a></p>\n<p>Errors such as:</p>\n<pre><code class=\"language-bash\"></code></pre>\n<h2>Factory Bot</h2>\n<ul>\n<li><a href=\"https://semaphoreci.com/community/tutorials/working-effectively-with-data-factories-using-factorygirl#introduction-to-factorybot\">https://semaphoreci.com/community/tutorials/working-effectively-with-data-factories-using-factorygirl#introduction-to-factorybot</a></li>\n<li><a href=\"https://github.com/thoughtbot/factory_bot/blob/master/GETTING_STARTED.md#best-practices\">https://github.com/thoughtbot/factory_bot/blob/master/GETTING_STARTED.md#best-practices</a></li>\n</ul>\n<h2>Service Objects</h2>\n<p><a href=\"https://www.toptal.com/ruby-on-rails/rails-service-objects-tutorial\">https://www.toptal.com/ruby-on-rails/rails-service-objects-tutorial</a></p>\n<h2>Reset the DB</h2>\n<p>Typically easy as <code>bundle exec rails db:reset</code> which will run <code>db:drop</code> and <code>db:setup</code>.</p>\n<p><code>db:setup</code> runs <code>db:create</code>, <code>db:schema:load</code>, <code>db:seed</code></p>\n<p>Or <code>bundle exec rails db:migrate:reset</code> which is <code>db:drop</code>, <code>db:create</code>, <code>db:migrate</code></p>\n<h3>Issues</h3>\n<ul>\n<li>Older versions of postgres require all connections closed to do a full reset.</li>\n<li>Newer versions of postgres will allow you to force with active connections but you must pass that in.</li>\n</ul>\n<h3>Workarounds</h3>\n<ul>\n<li>Kill all active connections, this can get annoying or difficult in a live env.</li>\n<li>Pass the force option if supported.</li>\n<li>Run <code>model_name.destroy_all</code> instead. (will not reset auto ids). Run truncate to reset auto ids.</li>\n</ul>\n<h2>Fake Data</h2>\n<ul>\n<li><a href=\"https://github.com/faker-ruby/faker#usage\">https://github.com/faker-ruby/faker#usage</a></li>\n<li><a href=\"https://pganalyze.com/blog/fastest-way-importing-data-into-postgres-with-ruby-rails\">https://pganalyze.com/blog/fastest-way-importing-data-into-postgres-with-ruby-rails</a></li>\n</ul>\n<h3>Performance</h3>\n<ul>\n<li><a href=\"https://www.cloudbees.com/blog/speeding-up-bulk-imports-in-rails\">https://www.cloudbees.com/blog/speeding-up-bulk-imports-in-rails</a></li>\n</ul>\n<ol>\n<li>Use background workers if possible i.e. sidekiq</li>\n</ol>\n<h3>Approaches</h3>\n<ol>\n<li>Seed data. Meant for data that is required and consistent.</li>\n<li>Scrub production data for <a href=\"https://thoughtbot.com/blog/anonymizing-user-company-and-location-data-using\">sensitive information</a>.</li>\n<li>Generate fake data. This can be improved to mimic production with statistics and code.</li>\n</ol>\n<h2>Getting statistics on existing data</h2>\n<ul>\n<li><a href=\"https://work.stevegrossi.com/2015/04/25/how-to-count-with-activerecord/\">https://work.stevegrossi.com/2015/04/25/how-to-count-with-activerecord/</a></li>\n</ul>\n<h3>Counts</h3>\n<ul>\n<li>\n<p>Use sql count. <code>Post.all.count</code> will perform a sql count on the posts table. i.e. <code>SELECT COUNT(*) FROM \"posts\"</code></p>\n</li>\n<li>\n<p><code>Post.all.to_a.count</code> will perform a full select and than count. Prefer the first method for performance.</p>\n</li>\n<li>\n<p><code>Post.all.length</code> is similar to a <code>to_a</code> count, but faster</p>\n</li>\n<li>\n<p><code>Post.all.size</code> will negotiate the fastest lookup, considering counter caches, etc. <strong>This should be preferred.</strong></p>\n</li>\n<li>\n<p><code>.group(:type).count</code> will group and count by the type field</p>\n</li>\n<li>\n<p><code>.group(:type).count.pluck(1)</code> will group and count by the type field and return just the numberic counts</p>\n</li>\n</ul>\n<h3>Stats</h3>\n<h2>Queries</h2>\n<p><code>Model.order(Arel.sql('RANDOM()')).first</code> will select the first random record in rails 6+</p>\n<h3>any?, empty?</h3>\n<ul>\n<li>Both will efficiently decide how to check.</li>\n<li>Mostly opposite with caveats.</li>\n<li><code>any?</code> has to check each element</li>\n<li><code>[false].empty?</code> is <code>false</code> because it contains an element</li>\n<li><code>[false].any?</code> is <code>false</code> because nothing is <code>true</code></li>\n</ul>\n<h2>Dynamic constants</h2>\n<p>Getting the model from a table name of 'users'</p>\n<ul>\n<li><code>:users.to_s</code> -> <code>\"users\"</code> simple string conversion</li>\n<li><code>:users.to_s.classify</code> -> <code>\"User\"</code>, used to get the model from a symbol</li>\n<li><code>:users.to_s.classify.constantize</code> -> <code> User(...)</code> returns the model as a symbol</li>\n<li><code>safe_constantize</code> will return nil if the model doesn't exist instead of an error</li>\n</ul>\n<p>Getting association information</p>\n<ul>\n<li><code>Author.reflect_on_association(:books).klass</code> returns the class/model of the association books</li>\n</ul>\n<h2>Rake</h2>\n<ul>\n<li><a href=\"https://www.lynnbright.com/6-tips-to-ensure-your-rake-task-runs-smoothly/\">https://www.lynnbright.com/6-tips-to-ensure-your-rake-task-runs-smoothly/</a></li>\n</ul>\n<h3>Passing arguments to a rake task</h3>\n<pre><code class=\"language-ruby\">namespace :db do\n  namespace :delete do\n    desc \"Reset data...\"\n    task :reset_data, [:truncate] => :environment do |_t, args|\n      # do stuff\n    end\n  end\nend\n</code></pre>\n<pre><code class=\"language-bash\">unsetopt nomatch # for zsh to avoid errors with non string args\nbundle exec rails db:delete:reset_data[true]\nbundle exec rails 'db:delete:reset_data[true]' # will pass 'true' as string always and works with bash/zsh\n</code></pre>\n<h3>Logs and timing</h3>\n<p>The utils will allow you to wrap a section with a message and collect timings. It also configures logging to stdout.</p>\n<pre><code class=\"language-ruby\">module FakeDataUtil\n  def wrap_with_log(log_prefix, message)\n    start_at = Time.zone.now\n    @logger.info \"[#{log_prefix}] #{message}\"\n    yield\n    end_at = Time.zone.now\n    duration = (end_at - start_at).to_i\n    @logger.info \"[#{log_prefix}] completed in #{duration}s\"\n  end\nend\n\n@logger = Logger.new(STDOUT, datetime_format: '%H:%M:%S')\ndesc 'Wait for transactions to create...'\ntask :wait_for_create_transactions => :environment do |_t|\n    include FakeDataUtil\n    @logger.progname = \"[#{_t.to_s}]\"\n    @logger.info \"START\"\n    wrap_with_log 'db:transactions', \"Waiting for job to complete...\" do\n    # do stuff\n    end\n    @logger.info \"END\"\nend\n</code></pre>\n<h3>Limit to envs</h3>\n<pre><code class=\"language-ruby\">raise 'You cannot run this in production' if Rails.env.production?\nraise 'You cannot run this in test, use the factories instead' if Rails.env.test?\n</code></pre>\n<h2>Modules and loading</h2>\n<ul>\n<li><a href=\"https://juzer-shakir.medium.com/accessing-module-in-root-in-ruby-8eb46dbb38e1\">https://juzer-shakir.medium.com/accessing-module-in-root-in-ruby-8eb46dbb38e1</a></li>\n<li><a href=\"https://blog.arkency.com/2014/11/dont-forget-about-eager-load-when-extending-autoload/\">https://blog.arkency.com/2014/11/dont-forget-about-eager-load-when-extending-autoload/</a></li>\n<li><a href=\"https://guides.rubyonrails.org/v5.2/autoloading_and_reloading_constants.html\">https://guides.rubyonrails.org/v5.2/autoloading_and_reloading_constants.html</a></li>\n</ul>\n<pre><code class=\"language-ruby\"># workers/fake_data.rb\nmodule FakeData\n  extend FakeDataUtil\n\n  def self.get_top_seniorities\n#   do stuff\n  end\nend\n\n# apps/utils/fake_data_util.rb\nmodule FakeDataUtil\n  def wrap_with_log(log_prefix, message)\n  end\nend\n\n# workers/fake_data/insert_companies_worker.rb\nmodule FakeData\n  class InsertCompaniesWorker\n    include Sidekiq::Worker\n    include FakeDataUtil\n\n    wrap_with_log ':db:companies', \"Creating #{total_companies} companies\" do\n      FakeData::get_top_seniorities\n    end\n  end\nend\n</code></pre>\n<h3>Errors</h3>\n<p><code>WARN: LoadError: Unable to autoload constant</code></p>\n<ul>\n<li>\n<p><a href=\"https://stackoverflow.com/questions/64548442/unable-to-autoload-constant-bug-in-rails-5-2-0/64601195#64601195\">https://stackoverflow.com/questions/64548442/unable-to-autoload-constant-bug-in-rails-5-2-0/64601195#64601195</a></p>\n</li>\n<li>\n<p><a href=\"https://www.bigbinary.com/blog/rails-5-disables-autoloading-after-booting-the-app-in-production\">https://www.bigbinary.com/blog/rails-5-disables-autoloading-after-booting-the-app-in-production</a></p>\n</li>\n<li>\n<p>If you have multiple files in a module (nested), add an empty module that matches the folder name.</p>\n</li>\n<li>\n<p>Rails 5.2 needs to define every module explicitly</p>\n</li>\n<li>\n<p>Autoloading is not thread safe, be careful in things like workers.</p>\n</li>\n</ul>\n<h2>Sidekiq</h2>\n<ul>\n<li><a href=\"https://dev.to/appaloosastore/active-record-sidekiq-pools-and-threads-18d5\">https://dev.to/appaloosastore/active-record-sidekiq-pools-and-threads-18d5</a></li>\n<li><a href=\"https://devcenter.heroku.com/articles/concurrency-and-database-connections\">https://devcenter.heroku.com/articles/concurrency-and-database-connections</a></li>\n<li><a href=\"https://github.com/sidekiq/sidekiq/wiki/Advanced-Options#concurrency\">https://github.com/sidekiq/sidekiq/wiki/Advanced-Options#concurrency</a></li>\n<li><a href=\"https://developer.workarea.com/articles/workers.html\">https://developer.workarea.com/articles/workers.html</a></li>\n</ul>\n<pre><code class=\"language-ruby\">@connection_pool_concurrency = ENV['RAILS_MAX_THREADS'] || 10\nsidekiq_options :queue => :add_fake_data,\n                :retry => 1,\n                :concurrency => @connection_pool_concurrency,\n                :fetch => :eager\n</code></pre>\n<p><code>:fetch => :eager</code> solves module loading issues, since they are not thread safe.\n<code>concurrency</code> sets number of threads for a worker, make sure you account for the db pool size.</p>\n<h3>Errors</h3>\n<pre><code class=\"language-bash\">could not obtain a connection from the pool within 5.000 seconds (waited 5.002 seconds); all pooled connections were in use (ActiveRecord::ConnectionTimeoutError)\n</code></pre>\n<ul>\n<li>Default sidekiq workers have 10 threads</li>\n<li>Connection pool should be equal to number of threads</li>\n<li>Active record connections clear after a default timeout which is much longer than 5 sec. Clearing the connections in workers may be a good idea.</li>\n</ul>\n<pre><code class=\"language-ruby\">ActiveRecord::Base.clear_active_connections!\n</code></pre>\n<p>Setting active record pool:</p>\n<pre><code class=\"language-ruby\">pool: &#x3C;%= ENV[\"DB_POOL\"] || ENV['RAILS_MAX_THREADS'] || 5 %>\n</code></pre>\n<p>check connections <code>bundle exec rails dbconsole</code></p>\n<pre><code class=\"language-sql\">select count(*) from pg_stat_activity where pid &#x3C;> pg_backend_pid() and usename = current_user;\n</code></pre>\n<h2>Routing</h2>\n<p><a href=\"https://guides.rubyonrails.org/routing.html\">https://guides.rubyonrails.org/routing.html</a></p>\n<p><code>resource</code> vs. <code>resources</code> is acting on one record vs many.</p>\n<p><code>resource</code> skips the index route and usually skips passing ids through.</p>\n<h2>Active Record</h2>\n<h3>Finding</h3>\n<ul>\n<li>\n<p><a href=\"https://www.rubyguides.com/2019/07/rails-where-method/\">https://www.rubyguides.com/2019/07/rails-where-method/</a></p>\n</li>\n<li>\n<p><code>find_by</code>, <code>find_by_&#x3C;key></code> returns a single record or nil</p>\n</li>\n<li>\n<p><code>where</code> returns <code>ActiveRecord::Relation</code></p>\n</li>\n<li>\n<p><code>find</code> a single record found by primary key, raise an exception if not found</p>\n</li>\n</ul>\n<h3>Scopes</h3>\n<ul>\n<li><a href=\"https://www.sitepoint.com/dynamically-chain-scopes-to-clean-up-large-sql-queries/\">https://www.sitepoint.com/dynamically-chain-scopes-to-clean-up-large-sql-queries/</a></li>\n<li><a href=\"https://guides.rubyonrails.org/active_record_querying.html#scopes\">https://guides.rubyonrails.org/active_record_querying.html#scopes</a></li>\n</ul>\n<p>A scope is a way to add custom lookups/finders outside the defaults. They can be chained.</p>\n<pre><code class=\"language-ruby\"># model\nscope :my_follows, ->(user_id) { where(user_id: user_id) }\n\n# controller\nFollow.my_follows(current_user.id)\n</code></pre>\n<h3>Validations</h3>\n<ul>\n<li><a href=\"https://guides.rubyonrails.org/v2.3.8/activerecord_validations_callbacks.html\">https://guides.rubyonrails.org/v2.3.8/activerecord_validations_callbacks.html</a></li>\n<li><a href=\"https://edgeguides.rubyonrails.org/active_record_validations.html#using-a-symbol-with-if-and-unless\">https://edgeguides.rubyonrails.org/active_record_validations.html#using-a-symbol-with-if-and-unless</a></li>\n</ul>\n<h3>Custom Validations</h3>\n<ul>\n<li><a href=\"https://guides.rubyonrails.org/v2.3.8/activerecord_validations_callbacks.html#creating-custom-validation-methods\">https://guides.rubyonrails.org/v2.3.8/activerecord_validations_callbacks.html#creating-custom-validation-methods</a></li>\n<li><a href=\"https://betterprogramming.pub/how-to-implement-custom-activerecord-validations-235543f5dd8c\">https://betterprogramming.pub/how-to-implement-custom-activerecord-validations-235543f5dd8c</a></li>\n<li><a href=\"https://api.rubyonrails.org/classes/ActiveModel/Errors.html#method-i-key-3F\">https://api.rubyonrails.org/classes/ActiveModel/Errors.html#method-i-key-3F</a></li>\n</ul>\n<pre><code class=\"language-ruby\">validate :resource_must_exist, unless: lambda {\n  errors.messages.include?(:resource_type) || errors.messages.include?(:resource_id)\n}\n\ndef resource_must_exist\n  resource\nend\n\ndef resource\n  resource_type.constantize.find_by!(id: resource_id)\nend\n</code></pre>\n<h2>Controllers</h2>\n<h3>Custom hooks</h3>\n<p><code>before_action</code> fires by default for all actions, can be limited to specific.</p>\n<pre><code class=\"language-ruby\">before_action :validate_resource_id\n\ndef validate_resource_id\n    return if permitted_params[:resource_id] &#x26;&#x26; permitted_params[:resource_type]\n\n    return unless permitted_params[:resource_id] &#x26;&#x26; !permitted_params[:resource_type]\n\n    render status: :bad_request,\n            json: {\n                errors: ['resource_type is required']\n            }\nend\n</code></pre>\n<h2>CORS</h2>\n<ul>\n<li><a href=\"https://github.com/cyu/rack-cors\">https://github.com/cyu/rack-cors</a></li>\n</ul>\n<p><code>config.enforce_ssl</code> should be enabled in higher environments if not all.</p>\n<p>If you absolutely must exclude a route or set of routes you can exclude the path. This may be something like health/liveness checks.</p>\n<p>If you make a request to an SSL enforced api it will complain about invalid requests or mismatch of protocol.</p>\n<pre><code class=\"language-ruby\">config.force_ssl = true\n\n# skip ssl for 'skipssl' path\nconfig.ssl_options = {\nredirect: {\n    exclude: -> request { request.path =~ /skipssl/ }\n}\n}\n</code></pre>\n<p>Allow cross site requests from various origins.</p>\n<pre><code class=\"language-ruby\"># config/initializers/cors.rb\nuse Rack::Cors do\n  allow do\n    origins 'localhost:3000', '127.0.0.1:3000',\n            /\\Ahttp:\\/\\/192\\.168\\.0\\.\\d{1,3}(:\\d+)?\\z/\n            # regular expressions can be used here\n    resource '*',\n             headers: :any,\n             methods: %i(get post put patch delete options head)\n  end\nend\n</code></pre>\n<p>In Rails make sure the origin header does not have a traling slash. An origin header is required for CORS.</p>","frontmatter":{"date":"May 28, 2023","title":"Ruby on Rails","tags":["ruby","Ruby on Rails","framework"]}}},"pageContext":{"slug":"/rails/"}},"staticQueryHashes":["1796642556","2356112386","3489759178"],"slicesMap":{}}