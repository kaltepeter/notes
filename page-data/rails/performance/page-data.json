{"componentChunkName":"component---src-templates-note-template-tsx","path":"/rails/performance/","result":{"data":{"markdownRemark":{"html":"<ul>\n<li><a href=\"https://collectiveidea.com/blog/archives/2015/02/19/optimizing-rails-for-memory-usage-part-1-before-you-optimize\">Optimizing Rails for Memory (4 parts)</a></li>\n</ul>\n<h2>Profiling</h2>\n<ul>\n<li><a href=\"https://github.com/tmm1/stackprof\">stackprof</a></li>\n</ul>\n<pre><code class=\"language-bash\">gem install stackprof\n</code></pre>\n<pre><code class=\"language-ruby\">StackProf.run(mode: :cpu, raw: true, out: 'tmp/stackprof-cpu-myapp.dump') do\n  #...\nend\n# mode: cpu, wall, object. use object for memory\n</code></pre>\n<ul>\n<li><a href=\"https://github.com/alisnic/stackprof-webnav\">stackprof webnav</a></li>\n</ul>\n<pre><code class=\"language-bash\">gem install stackprof-webnav\nstackprof-webnav -f /path/to/stackprof.dump\n</code></pre>\n<h2>Active Record</h2>\n<ul>\n<li><a href=\"https://www.rubyinrails.com/2019/09/17/rails-find-in-batches-vs-find-each/\">find_in_batches vs. find_each</a></li>\n</ul>\n<h3>Maximum Number / Calculate Needs</h3>\n<blockquote>\n<p>A released connection will be returned to the pool, but not disconnect from the database server. The connection will remain connected in the pool, waiting for a new thread to request a connection. Hence the connection will count against your database server's maximum number of connections.</p>\n</blockquote>\n<blockquote>\n<p>Only when a connection in the pool remains unused for more than 5 minutes, ActiveRecord will actually close the connection. You can configure this by setting the idle_timeout in your database.yml.</p>\n</blockquote>\n<p>-- <a href=\"https://makandracards.com/makandra/45360-using-activerecord-with-threads-might-use-more-database-connections-than-you-think\">Using ActiveRecord with threads might use more database connections than you think</a></p>\n<p><code>(2 pods * 3 workers) * (1 pod * 10 sidekiq workers) = 6 * 10 = 60 connections</code></p>\n<p><code>((2 pods * 3 workers) * (1 pod * 10 sidekiq workers)) * 5 threads = (6 * 10) * 5 = 300 connections</code></p>\n<p><code>reaping_frequency</code>: when to look for connections from inactive threads</p>\n<p><code>ActiveRecord::Base.clear_active_connections!</code>: clears all active connections and diconnects forcibly</p>\n<p><code>ActiveRecord::Base.connection_pool.release_connection</code>: releases the connection back to the pool without disconnecting so it can be reused</p>\n<h2>Reducing memory</h2>\n<ul>\n<li><a href=\"https://github.com/rails/rails/issues/46436\">find_each memory leak</a></li>\n<li><a href=\"https://answers.abstractbrain.com/how-to-reduce-memory-usage-in-ruby\">how to reduce memory usage in ruby</a></li>\n</ul>\n<ol>\n<li>reduce sidekiq threads</li>\n<li>use <code>MALLOC_ARENA_MAX=2</code> as an env var</li>\n</ol>\n<h2>Caching</h2>\n<ul>\n<li><a href=\"https://www.bigbinary.com/blog/caching-in-development-environment-in-rails5\">Caching in development environment in Rails 5</a></li>\n</ul>\n<pre><code class=\"language-bash\">rails dev:cache # will enable/disable the cache if you have the default config in rails 5+\n</code></pre>\n<p>Example cache config in development.rb</p>\n<pre><code class=\"language-ruby\">if Rails.root.join('tmp/caching-dev.txt').exist?\n  config.action_controller.perform_caching = true\n  config.static_cache_control = \"public, max-age=172800\"\n  config.cache_store = :mem_cache_store\nelse\n  config.action_controller.perform_caching = false\n  config.cache_store = :null_store\nend\n</code></pre>","frontmatter":{"date":"November 25, 2023","title":"Ruby on Rails: Performance","tags":["ruby","Ruby on Rails","framework","performance"]}}},"pageContext":{"slug":"/rails/performance/"}},"staticQueryHashes":["1796642556","2356112386","3489759178"],"slicesMap":{}}