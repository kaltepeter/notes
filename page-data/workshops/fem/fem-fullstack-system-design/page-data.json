{"componentChunkName":"component---src-templates-note-template-tsx","path":"/workshops/fem/fem-fullstack-system-design/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://frontendmasters.com/workshops/fullstack-system-design/\">https://frontendmasters.com/workshops/fullstack-system-design/</a></p>\n<h2>Tools</h2>\n<ul>\n<li><a href=\"https://app.diagrams.net/\">https://app.diagrams.net/</a></li>\n</ul>\n<h2>Diagramming</h2>\n<h3>Pizza Shop</h3>\n<ol>\n<li>Customer places an order</li>\n<li>Resteraunt receives the order</li>\n<li>Staff takes the order after completing other orders</li>\n<li>If missing ingredients, has to prepare/acquire them</li>\n<li>Order ready: delivery or in store</li>\n<li>Customer receives order</li>\n</ol>\n<p>Pizza Ordereed</p>\n<pre><code class=\"language-mermaid\">graph TD\n   A1[Cusomter Places Phone Order] --> C{Order Received}\n   A2[Cusomter Places Website Order] --> C{Order Received}\n   A3[Cusomter Places In Store Order] --> C{Order Received}\n   B[Take Payment]\n   C[Staff Receives Order]\n   C --> |Staff Busy| C\n   C --> |Has Ingredients| D\n   C --> |Missing Ingredients| D\n   D[Staff Makes Order] --> E\n   E[Counter or Delivery Receives Complete Order]\n   E --> |Paid| F\n   E --> |Needs payment| B --> E\n   F[Customer Gets Order]\n   G[Acquire/Prepare Ingredients] --> D\n\n</code></pre>\n<h3>Flow</h3>\n<pre><code class=\"language-mermaid\">graph TD\n    A[Client]\n    A --> |Cache Hit| C\n    A --> |Cache Miss| B(Send Request)\n    B[Load Balancer or CDN] --> D\n    C@{ shape: diamond, label: \"Cache\" } --> A\n    D[Server]\n    D --> |Cache Hit| A\n    D --> |Cache Miss| F(Return Data)\n    E@{ shape: diamond, label: \"Cache\" }\n    F@{shape: cyl, label: 'Database'} --> E\n</code></pre>\n<h2>Translating Business Requirements</h2>\n<h3>TODO App</h3>\n<ul>\n<li>\n<p>What is actually needed?</p>\n</li>\n<li>\n<p>Create a TODO</p>\n</li>\n<li>\n<p>Read a TODO or list</p>\n</li>\n<li>\n<p>Update a TODO</p>\n</li>\n<li>\n<p>Complete a TODO</p>\n</li>\n<li>\n<p>Delete a TODO</p>\n</li>\n</ul>\n<h3>Mobile Banking</h3>\n<ul>\n<li>\n<p>How realtime?</p>\n</li>\n<li></li>\n<li>\n<p>Manage Users: CRUD</p>\n</li>\n<li>\n<p>Authenticate a User</p>\n</li>\n<li>\n<p>Authorize a User</p>\n</li>\n<li>\n<p>Display recent transactions</p>\n</li>\n<li>\n<p>Display historical transactions</p>\n</li>\n<li>\n<p>Make a payment</p>\n</li>\n<li>\n<p>Transfer money</p>\n</li>\n<li>\n<p>Withdraw money</p>\n</li>\n<li>\n<p>Show Balance</p>\n</li>\n<li>\n<p>Apple/Google Pay</p>\n</li>\n</ul>\n<p>Non-functional</p>\n<ul>\n<li>performant, very fast</li>\n<li>live data</li>\n<li>secure</li>\n</ul>\n<h3>URL Shortener</h3>\n<p>Questions:</p>\n<ul>\n<li>Can users customize the shortened URL?</li>\n<li>How long are short URLs persisted?</li>\n<li>What about keys/duplicates?</li>\n<li>What happens if the site is no longer available?</li>\n<li>How long is too long for short?</li>\n<li>HTTPS?</li>\n<li>Performance expectations</li>\n<li>Can a URL change?</li>\n<li>Can a URL be deleted?</li>\n</ul>\n<p>Functional:</p>\n<ul>\n<li>Users should be able to convert long URL's into shortened versions</li>\n<li></li>\n</ul>\n<h3>TODO App</h3>\n<p>Functional</p>\n<ul>\n<li>tasks can only be text</li>\n<li>users should be able to:\n<ul>\n<li>read their todos</li>\n<li>edit todos</li>\n<li>create new todos</li>\n<li>mark a todo as complete</li>\n<li>delete a todo</li>\n<li>reorder todos</li>\n<li>create a list</li>\n<li>edit list</li>\n<li>filter or sort</li>\n<li>delete a list</li>\n<li><del>share a list</del></li>\n<li>create account</li>\n<li>login</li>\n</ul>\n</li>\n</ul>\n<p>non-functional</p>\n<ul>\n<li>only authenticated users can access tasks</li>\n<li>task oeprations must complete within 1000ms</li>\n<li></li>\n</ul>\n<h2>CAP Theorem</h2>\n<ul>\n<li>Realiability: ability for a system to function correctly over time</li>\n<li>Availability: proportion of time a system is operational and accessible</li>\n<li>Resiliency: how well does the system handle failures</li>\n<li>Consistency: how do we ensure that all the users see the same data at the same time</li>\n</ul>\n<p>Distributed systems can only guarentee 2 of 3 at a time.</p>\n<p>Consistency: every read receives the most recent write on error\nAvailability: a request for data gets a response, even if one or more nodes are dow\nPartition Tolerance: the cluster must continue to work despite any number of communication breakdowns between nodes in the system.</p>\n<ul>\n<li><del>C + A: only works without network issues</del></li>\n<li>C + P: Always show the latest data but unreliable performance</li>\n<li>A + P: Always responds but might who outdated data</li>\n</ul>\n<h2>Non-functional Requirements</h2>\n<h3>Mobile Banking</h3>\n<ul>\n<li>How many MAU's?</li>\n<li>How many transactions per user?</li>\n<li>How often do users have to transfer money, i.e. write through the app</li>\n<li>How often do the users use the app per month?</li>\n<li></li>\n</ul>\n<p>Non-functional</p>\n<ul>\n<li>the system should have 4 nines of availability</li>\n<li>transactions should be backed up daily</li>\n<li>transaction data must be encrpyted in transit at rest</li>\n<li>transactions cannot be lost</li>\n<li>every transaction and user action must be audited</li>\n</ul>\n<h3>URL Shortener</h3>\n<ul>\n<li>How many MAUs?</li>\n<li>What is the average requests per second?</li>\n<li>What is the maximum latency allowed?</li>\n<li>What is the max length of the URL?</li>\n<li>Do URL's expire?</li>\n</ul>\n<p>Non-functional</p>\n<ul>\n<li>Redirects should happen in no more than 500ms</li>\n<li>the system should support 1 million RPS</li>\n<li>long URLS can be at most 3kb</li>\n<li>short urls can at most 0.3kb</li>\n<li></li>\n</ul>\n<h2>Modeling</h2>\n<pre><code class=\"language-mermaid\">graph LR\n  A[Requirements] --> B\n  B[Entity Modeling] --> C\n  C[API Design] --> D\n  D[Endpoints Optional]\n</code></pre>\n<p>Entities</p>\n<pre><code class=\"language-mermaid\">erDiagram\n    USER ||--o{ TASK : has\n    USER ||--o{ LIST : has\n    USER {\n        string username\n        string password\n        string id\n    }\n    TASK {\n        string contents\n        string status\n        string id\n    }\n    LIST }|..o{ TASK: contains\n    LIST {\n        string description\n        string tasks\n        string id\n    }\n</code></pre>\n<h2>Protocols</h2>\n<ul>\n<li>HTTP: stateless, simple, human readable, supported by all browsers</li>\n<li>Websockets: bi-directional communication, peristent connection</li>\n<li>Server Side Events: one way communication (server to client), human readable</li>\n<li>gRPC: binary protocol (HTTP/2), Strongly-types contracts</li>\n<li>REST: multiple endpoints, human readable, supported by all, stateless</li>\n<li>GraphQL: single endpoint, precise data retrieval, self documenting API, strongly typed</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[Is this internal service-to-service communication?] --> |Yes| E\n    A --> |No| B\n    B[Do you read need realtime updates?] --> |Yes| C\n    B --> |No| D\n    C[Do you need bi-directional communication?] --> |Yes| F\n    C --> |No| G\n    D[Do you have complex data from many sources?] --> |Yes| H\n    D --> |No| I\n    E[consider gRPC]\n    F[WebSockets]\n    G[Server-Sent Events]\n    H[GraphQL]\n    I[REST]\n</code></pre>\n<h2>Database Scaling</h2>\n<h3>Partiioning</h3>\n<ul>\n<li>Same DB</li>\n<li>Easier</li>\n<li>Transactional guarentees</li>\n<li>Queries span multiple tables</li>\n</ul>\n<h3>Sharding</h3>\n<ul>\n<li>Load balanced over different machines</li>\n<li></li>\n</ul>\n<h2>Replication</h2>\n<ul>\n<li>making copies of your data across multiple servers or locations</li>\n<li>increases fault tolerance</li>\n<li>increases read performance</li>\n</ul>\n<h3>Primary / Replica</h3>\n<ul>\n<li>All writes go to the primary server</li>\n<li>Replicas copy data from the primary and handle read requests</li>\n<li>If the primary fails, a replica can take over</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[Service] --> |READ| D\n    B[Service] --> |WRITE| E\n    C[Service] --> |READ| F\n    D[Replica] --> |READ| E\n    E[Primary]\n    F[Replica] --> |READ| E\n</code></pre>\n<h3>Primary / Primary</h3>\n<ul>\n<li>Multiple servers acept reads/writes</li>\n<li>Data is synchonized between all servers</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[Service] --> |READ/WRITE| D\n    B[Service] --> |READ/WRITE| E\n    C[Service] --> |READ/WRITE| F\n    D[Primary] &#x3C;--> E\n    E[Primary] \n    F[Primary] &#x3C;--> E\n</code></pre>\n<h3>Peer to Peer</h3>\n<ul>\n<li>Every server can read and write</li>\n<li>Changes are shared with all other servers</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[Peer A] &#x3C;--> D\n    B[Peer B] &#x3C;--> C\n    C[Peer C]\n    D[Peer D]\n    A &#x3C;--> B &#x26; C &#x3C;--> D\n</code></pre>\n<h3>Strategies</h3>\n<ul>\n<li>Transactional</li>\n<li>Snapshotting</li>\n<li>Merging</li>\n</ul>\n<h2>Caching</h2>\n<h3>Cache Aside (Lazy Loading) READ</h3>\n<ol>\n<li>Cache miss</li>\n<li>Read from database</li>\n<li>Update Cache</li>\n</ol>\n<pre><code class=\"language-mermaid\">graph LR\n  A[Service] --> |3 WRITE| B\n  A --> |2 READ| C\n  B@{ shape: diamond, label: \"cache\" } --> |1| A\n  C@{ shape: database, label: \"database\" }\n</code></pre>\n<h3>Cache Aside (Lazy Loading) WRITE</h3>\n<ol>\n<li>Write to database</li>\n<li>Write to cache</li>\n</ol>\n<pre><code class=\"language-mermaid\">graph LR\n  A[Service] --> |1 WRITE| C\n  A --> |2 WRITE| B\n  B@{ shape: diamond, label: \"cache\" } \n  C@{ shape: database, label: \"database\" }\n</code></pre>\n<h3>Write Through</h3>\n<ol>\n<li>Write to cache</li>\n<li>Write to DB</li>\n</ol>\n<pre><code class=\"language-mermaid\">graph LR\n  A[Service] --> |1 WRITE| B\n  B@{ shape: diamond, label: \"cache\" } \n  B --> |2 WRITE| C\n  C@{ shape: database, label: \"database\" }\n</code></pre>\n<h3>Read Through</h3>\n<ol>\n<li>Read from cache</li>\n<li>on miss, read from db</li>\n<li>write to cache</li>\n</ol>\n<pre><code class=\"language-mermaid\">graph LR\n  A[Service] --> |1 READ| B\n  B --> |cache hit| A\n  B@{ shape: diamond, label: \"cache\" }  --> |2 READ| C\n  C@{ shape: database, label: \"database\" }\n  C --> |3| B\n</code></pre>\n<h3>Write Behind</h3>\n<ol>\n<li>write to cache</li>\n<li>immediately return</li>\n<li>asynchronously, write to db</li>\n</ol>\n<pre><code class=\"language-mermaid\">graph LR\n  A[Service] --> |1 WRITE| B\n  B --> |2| A\n  B@{ shape: diamond, label: \"cache\" }  --> |3 WRITE| C\n  C@{ shape: database, label: \"database\" }\n</code></pre>\n<h3>Cache Invalidation</h3>\n<ul>\n<li>Time-based expiration (TTL)</li>\n<li>Event-based</li>\n<li>Version tagging</li>\n<li>Refresh ahead</li>\n</ul>\n<h3>Cache Eviction</h3>\n<p>LRU is a double linked used.</p>\n<ul>\n<li>FIFO: first in first out</li>\n<li>LIFO: last in first out</li>\n<li>LRU: least recently used</li>\n<li>MRU: most recently used</li>\n<li>LFU: least frequently used</li>\n<li>RR: random replacement</li>\n</ul>\n<h2>Estimations</h2>\n<ul>\n<li>help ground vague requirements in reality</li>\n<li>helps you think about the speficis of the system components</li>\n<li>shows the interviewer your thought process</li>\n<li>don't have to be precise</li>\n</ul>\n<h3>Strategy</h3>\n<ul>\n<li>clarify\n<ul>\n<li>what are you estimating?\n<ul>\n<li>users, requests, storage</li>\n</ul>\n</li>\n<li>ask or make reasonable assumptions\n<ul>\n<li>how many users?</li>\n</ul>\n</li>\n<li>validate your assumptions\n<ul>\n<li>write it down</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>do the math</li>\n<li>sanity check the results</li>\n</ul>\n<h2>TODO System Design</h2>\n<h2>Questions</h2>\n<h2>Requirements</h2>\n<pre><code class=\"language-mermaid\">graph LR\n    A@{shape: curv-trap, label: 'client'} -->B\n    A -->|client| FEC\n    FEC@{shape: diamond, label: 'cache'}\n    B[reverse proxy] -->GO\n    B -->WC\n    subgraph GO\n        direction TB\n        D[web server]\n        E[web server]\n    end\n    GO -->F\n    F[load balancer]\n    F --> C1\n    F --> C2\n    F --> C3\n    WC[cache] --> AUS\n    AUS[autoupdate server] -->F\n    C1@{shape: diamond, label: 'redis cache'} -->|READ| DBR1\n    C2@{shape: diamond, label: 'redis cache'}  -->|WRITE| DBW1\n    C3@{shape: diamond, label: 'redis cache'}  -->|READ| DBR2\n    DBR1@{shape: database, label: 'database'}\n    DBR1 -->|READ| DBW1\n    DBW1@{shape: database, label: 'database'}\n    DBR2@{shape: database, label: 'database'}\n    DBR2 -->|READ| DBW1\n</code></pre>\n<h2>Security</h2>\n<p>SSL./tls</p>\n<ul>\n<li>option 1: termination at load balancer\n<ul>\n<li>most common</li>\n<li>application receives http</li>\n</ul>\n</li>\n<li>option 2: termination at application layer\n<ul>\n<li>load balancer passes through encrypted traffic</li>\n<li>each application instance handles decryption</li>\n</ul>\n</li>\n<li>option 3: re-encryption\n<ul>\n<li>terminate at load balancer</li>\n<li>re-encrypt between load balancer and applications</li>\n</ul>\n</li>\n</ul>\n<h3>Authentication</h3>\n<p>Who are you?</p>\n<h3>Authorization</h3>\n<p>Determines permissions, what can you do?</p>\n<h2>Asynchorinicity</h2>\n<ul>\n<li>help adders the challenge of working with computationally expensive tasks</li>\n<li>keep the system responsive</li>\n</ul>\n<h3>Expensive Tasks</h3>\n<ul>\n<li>uploading and processing a large video file</li>\n<li>generating a report</li>\n<li>processing payments</li>\n<li>image resizing or thumbnail creation</li>\n</ul>\n<h3>Components</h3>\n<ul>\n<li>message broker\n<ul>\n<li>rabbitMQ</li>\n<li>kafka</li>\n</ul>\n</li>\n<li>message queue\n<ul>\n<li>rabbitMQ</li>\n<li>Amazon SQS</li>\n</ul>\n</li>\n<li>worker management\n<ul>\n<li>kubernetes</li>\n</ul>\n</li>\n</ul>\n<h2>Video Upload Service</h2>\n<ul>\n<li>supported resolutions / formats?</li>\n<li>is there a size limit?</li>\n<li>do we need generated thumbnails?</li>\n<li>how many users are uploading at once?</li>\n<li>do we need to process videos?</li>\n<li>do we need captions / subtitles</li>\n<li>do we need to process audio?</li>\n</ul>\n<p>features</p>\n<ul>\n<li>up to 4k</li>\n<li>max filesize 4g</li>\n<li>1 upload per user / day @ 1000 users</li>\n<li>yes thumbnails</li>\n<li>no trim/edit</li>\n<li>not today for captions</li>\n<li>yes on audio</li>\n<li>audio track is separate</li>\n<li>no perf metrics on upload speed</li>\n</ul>\n<p>entities</p>\n<pre><code class=\"language-mermaid\">erDiagram\n    USER ||--o{ MANIFEST : has\n    USER ||--o{ VIDEO  : uploads\n    METADATA ||--o{ VIDEO : has\n    METADATA ||--o{ AUDIO : has\n    METADATA ||--o{ THUMBNAILS : has\n    VIDEO\n    THUMBNAILS\n    AUDIO\n    METADATA\n    MANIFEST\n\n    USER {\n        string username\n        string password\n        string id\n    }\n</code></pre>\n<ul>\n<li>user gives a title</li>\n<li>user starts uploading a video</li>\n<li>user is notified when upload is successful</li>\n<li>process video</li>\n<li>user notified when processing complete</li>\n<li></li>\n</ul>\n<pre><code class=\"language-mermaid\">graph TD\n    C[client] -->|POST videos| W\n    W[web server] -->|video| SV\n    W --> MDB\n    SV[source video storage] --> N\n    N[notification service] -->|notify| P\n    N -->|notify| C\n    P[video processing service]\n    subgraph B[\"`\n        convert to 4k\n        convert to HD\n    `\"]\n        B1[queue]\n        B2[queue]\n    end\n    B --> W\n    MDB@{shape: database, label: \"database\"}\n    MDB --> A\n    A@{shape: database, label: 'audio'}\n    subgraph W [\"video broker\"]\n        W1[worker]\n        W2[worker]\n    end\n    subgraph AB [\"audio broker\"]\n        B1[queue]\n        B2[queue]\n    end\n    AB --> AW\n    subgraph AW\n        W1[worker]\n        W2[worker]\n    end\n    PV[processed video storage]\n    PV -->|get video| SV\n    PV --> B\n</code></pre>","frontmatter":{"date":"November 06, 2025","title":"FEM: Fullstack System Design","tags":["workshop","front-end-masters",null]}}},"pageContext":{"slug":"/workshops/fem/fem-fullstack-system-design/"}},"staticQueryHashes":["1796642556","2356112386","3489759178"],"slicesMap":{}}