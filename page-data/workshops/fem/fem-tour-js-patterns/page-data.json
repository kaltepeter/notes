{
    "componentChunkName": "component---src-templates-note-template-tsx",
    "path": "/workshops/fem/fem-tour-js-patterns/",
    "result": {"data":{"markdownRemark":{"html":"<h1>A Tour of JS Patterns</h1>\n<ul>\n<li><a href=\"https://javascriptpatterns.vercel.app/patterns/design-patterns/singleton-pattern\">https://javascriptpatterns.vercel.app/patterns/design-patterns/singleton-pattern</a></li>\n<li><a href=\"https://frontendmasters.com/courses/tour-js-patterns/\">https://frontendmasters.com/courses/tour-js-patterns/</a></li>\n<li><a href=\"https://www.patterns.dev/\">https://www.patterns.dev/</a></li>\n<li><a href=\"https://leanpub.com/composingsoftware\">https://leanpub.com/composingsoftware</a></li>\n<li><a href=\"https://www.theavocoder.com/\">https://www.theavocoder.com/</a></li>\n</ul>\n<p>✅ ⚠️ ⛔</p>\n<h3>Module Pattern</h3>\n<p>✅ encapsulation: controls public/private footprint\n✅ reusability: can be used in entire app</p>\n<p><code>type=\"module\"</code> or use <code>.mjs</code> extension</p>\n<h3>Singleton Pattern</h3>\n<p>Use case: ensure a single DB connection\n✅ memory: can save memory for one instance\n⚠️ unnecessary: ES2015 modules are singletons\n⚠️ dependency hiding: it's not clear that you are using a singleton\n⚠️ global scope pollution: they are global vars\n⚠️ testing: reset after every test</p>\n<p>Make sure to export the instance not the class and freeze objects.</p>\n<pre><code>// 2. Freeze the object using the `Object.freeze` method, to ensure the object is not modifiable.\nconst singletonCounter = Object.freeze(counterObject);\n\n// 3. Export the object as the `default` value to make it globally accessible.\nexport default singletonCounter;\n</code></pre>\n<h3>Proxy Pattern</h3>\n<p>Use case: validation, logging, formatting, notifications, debugging</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></li>\n</ul>\n<p>✅ Control: see use cases\n⚠️ Long handler execution can cause performance problems</p>\n<p>Reflect returns a truthy value which is important for proxies.</p>\n<h3>Observer</h3>\n<p>✅ separation of concerns, loose coupling\n⚠️ notifying all observers can take a lot of time if it becomes complex or if there are too many observers to notify</p>\n<p>Could parallelize if promises or similar.</p>\n<ul>\n<li><a href=\"https://frontendmasters.com/learn/async-rx-js/\">https://frontendmasters.com/learn/async-rx-js/</a></li>\n</ul>\n<h3>Factory</h3>\n<p>✅ DRY\n⚠️ Not very memory efficient or useful in js</p>\n<p>A function that returns objects</p>\n<h3>Prototype</h3>\n<p>✅ memory efficient. Items are stored on the prototype rather than each instance\n⚠️ Readability. With multiple extensions it's hard to see where properties came from.</p>\n<p><code>__proto__</code> shows prototype</p>\n<h3>Container/Presentation Pattern</h3>\n<p>Separate logic from the view.\n✅ separation of concerns. the presentation can be pure functions\n✅ reusability. views don't affect state\n✅ testing, eay pure functions\n⚠️ Not necessary with hooks, they achieve the same thing\n⚠️ overkill for smaller applications</p>\n<h3>HOC</h3>\n<p>Wraps a component and adds props, extracts logic\n✅ separation of concerns\n⚠️ naming collisions\n⚠️ readability</p>\n<h2>Render Props</h2>\n<p>Passing components as props to other components\n✅ Reusability\n✅ Separation of concerns\n✅ Solution to HOC problems\n⚠️ Unessesary with hooks</p>\n<h2>Hooks</h2>\n<p>Add state to functional components, reuse stateful logic, and manage component lifecycle.</p>\n<p>✅ Simplifies components\n✅ Reusing stateful logic\n✅ Sharing non-visual logic\n✅ Good alternative to older react design patterns.\n⚠️ Rules of hooks.</p>\n<h2>Provider Pattern</h2>\n<p>A HOC that allows passing a context.\n✅ scalability\n⚠️ components that consume the provider context re-render whenever a value changes</p>\n<h2>Compound Pattern</h2>\n<p>Multiple components work together for a single task.\n✅ State management, compound components manage their own internal state and share with children.\n✅ single import\n⚠️ Nested components. Only direct children have access to props\n⚠️ Naming collisions. Cloning performs a shallow merge.</p>\n<h2>Bundling/Tree-shaking/compiling</h2>\n<h3>Bundlers</h3>\n<p>Bundles the application in one or multiple files, making it possible to run in other environments.</p>\n<ul>\n<li><a href=\"https://webpack.js.org/\">Webpack</a> (We'll be using this one in the following examples)</li>\n<li><a href=\"https://parceljs.org/\">Parcel</a></li>\n<li><a href=\"https://rollupjs.org/guide/en/\">Rollup</a></li>\n<li><a href=\"https://frontendmasters.com/learn/webpack/\">https://frontendmasters.com/learn/webpack/</a></li>\n</ul>\n<h3>Compilers</h3>\n<p>Converts javascript or Typescript into another version.</p>\n<ul>\n<li><a href=\"https://babeljs.io/\">Babel</a></li>\n<li><a href=\"https://www.typescriptlang.org/\">TypeScript</a></li>\n</ul>\n<h3>Minifiers</h3>\n<p>Reduce the size by removing comments, making variable and function names smaller, removing white space, etc.</p>\n<ul>\n<li><a href=\"https://terser.org/\">Terser</a></li>\n<li><a href=\"https://www.uglifyjs.net/\">Uglify</a></li>\n</ul>\n<h3>Combination</h3>\n<p>There are tools that combine the steps</p>\n<ul>\n<li><a href=\"https://swc.rs/\">SWC</a> - a Rust-based compiler, bundler, and minifier</li>\n<li><a href=\"https://esbuild.github.io/\">ESBuild</a> - a Go-based compiler, bundler, and minifier.</li>\n</ul>\n<h3>Bundle Splitting</h3>\n<p>Creating multiple, smaller bundles rather than one large bundle.</p>\n<h3>Tree shaking</h3>\n<p>Dropping unused code</p>\n<h2>Static Import</h2>\n<p>Importing code exported by another file. As long as you only import used classes it can only bring in what is needed.</p>\n<pre><code>import module1 from './module1'\n</code></pre>\n<p>✅ loading instant dependencies. They are compiled this way\n✅ optimizations. Statically imported modules are analyzed and tree-shaked\n⚠️ Large bundle size. If importing all, you might bring in unneeded code</p>\n<h2>Dynamic Import</h2>\n<p>Import code on demand. Static imports are bundled and included. Dynamically imported is the run time, when the user interacts.</p>\n<p>✅ Faster initial load.\n⚠️ Layout shift. The dynamic layout can shift.\n⚠️ User experience. Lazy loading needs an initial render, which may be long.</p>\n<h2>Import on Visibility</h2>\n<p>Load non-critical components when they are visible.</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\">https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API</a></li>\n<li><a href=\"https://www.npmjs.com/package/react-intersection-observer\">https://www.npmjs.com/package/react-intersection-observer</a></li>\n<li></li>\n</ul>\n<p>✅ Faster initial load.\n⚠️ Layout shift. If the fallback component differs the layout will shift.</p>\n<h2>Route Based Splitting</h2>\n<p>Dynamically load components based on the current route.</p>\n<p>✅ Faster initial load.</p>\n<h2>Browser Hints</h2>\n<p>Use hints to tell the browser about (optionally) critical resources.</p>\n<h3>Prefetch</h3>\n<p>Fetch and cache the resources that may be requested soon.</p>\n<pre><code class=\"language-html\">&#x3C;link rel=\"prefetch\" href=\"./about.bundle.js\" />\n</code></pre>\n<pre><code class=\"language-typescript\">const About = lazy(() => import(/* webpackPrefetch: true */ \"./about\"));\n</code></pre>\n<p>✅ loading time\n⚠️ unnecessary. If the user never needed the resource, it was extra.</p>\n<h3>Preload</h3>\n<p>Inform the browser of critical resources before they are discovered.</p>\n<p>Will fetch no matter what.</p>\n<pre><code class=\"language-html\">&#x3C;link rel=\"preload\" href=\"./search-flyout.bundle.js\" />\n</code></pre>\n<pre><code class=\"language-typescript\">const SearchFlyout = lazy(() =>\n  import(/* webpackPreload: true */ \"./SearchFlyout\")\n);\n</code></pre>\n<p>✅ loading time\n✅ layout shift. preloading styles, fonts, and images can reduce layout shifts.\n⚠️ performance. they get fetched regardless of need. Only preload items that are instantly necessary.</p>\n<h2>Rendering</h2>\n<ul>\n<li><a href=\"https://www.theavocoder.com/blog/rendering-patterns\">https://www.theavocoder.com/blog/rendering-patterns</a></li>\n</ul>\n<h3>Web Vitals</h3>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TTFB</td>\n<td>Time to First Byte</td>\n<td>Time it takes for a client to receive the first byte of page content</td>\n</tr>\n<tr>\n<td>FCP</td>\n<td>First Contentful Paint</td>\n<td>Time it takes the browser to render the first piece of content after navigation</td>\n</tr>\n<tr>\n<td>LCP</td>\n<td>Largest Contentful Paint</td>\n<td>Time it takes to load and render the page's main content</td>\n</tr>\n<tr>\n<td>TTI</td>\n<td>Time To Interactive</td>\n<td>Time from when the page starts loading to when it's reliably responding to user input quickly</td>\n</tr>\n<tr>\n<td>CLS</td>\n<td>Cumulative Layout Shift</td>\n<td>Measures visual stability to avoid unexpected layout shift</td>\n</tr>\n<tr>\n<td>FIP</td>\n<td>First Input Delay</td>\n<td>Time from when the user interacts with the page to the time when the event handlers are able to run</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>Compiling</strong>: Converting JavaScript into native machine code\n<strong>Execution time</strong>: The time it takes to execute the previously fetched, parsed, and compiled data\n<strong>Hydration</strong>: Attaching handlers to a DOM node whose HTML contents were server-rendered, making the component interactive\n<strong>Idle</strong>: The browser's state when it's not performing any action - <strong>Loading time</strong>: The time it takes to fetch the data from the server\n<strong>Main thread</strong>: The thread on which the browser executes all the JavaScript, performs layout, reflows, and garbage collection\n<strong>Parsing</strong>: Converting an HTML source into DOM nodes, and generating an AST\n<strong>Processing</strong>: Parsing, compiling, and executing the previously fetched data\n<strong>Processing time</strong>: The time it takes to parse and compile the previously fetched data\n-- <a href=\"https://javascriptpatterns.vercel.app/patterns/rendering-patterns/introduction\">https://javascriptpatterns.vercel.app/patterns/rendering-patterns/introduction</a></p>\n</blockquote>\n<h3>Client-side rendering</h3>\n<p>SPAs, the client does the rendering.</p>\n<p><img src=\"../../../images/perf-client-side-rendering.png\" alt=\"Performance of Client Side Rendering\"></p>\n<p>✅ Interactivity\n✅ Single server roundtrip\n⚠️ Bundle size\n⚠️ SEO</p>\n<h3>Static rendering</h3>\n<p>Deliver pre-rendered HTML content that was generated when the site was built.</p>\n<p><img src=\"../../../images/perf-static-rendering.png\" alt=\"Performance of Static Rendering\"></p>\n<p>✅ Cacheability. Can be used with a CDN.\n✅ SEO\n✅ Availability. Always online\n✅ Backend load.\n⚠️ Dynamic data. If there is dynamic data it can be a long LCP.</p>\n<h3>Dynamic data</h3>\n<p>Adding dynamic data to static pages. Frameworks such as Next.js support it.</p>\n<p><img src=\"../../../images/perf-dynamic-data.png\" alt=\"Performance of Dynamic Data\"></p>\n<p>✅ Static benefits.\n✅ Dynamic data.\n⚠️ Redeployment is needed to refresh data.\n⚠️ Long build times.</p>\n<h3>Fetching dynamic data client side</h3>\n<p>Using client-side fetch to add dynamic data.</p>\n<p><img src=\"../../../images/perf-fetching-dynamic-data-client-side.png\" alt=\"Performance of Fetching Dynamic Data Client Side\"></p>\n<p>✅ Static benefits.\n⚠️ Server costs\n⚠️ Layout shifts</p>\n<h2>Incremental Static Regeneration</h2>\n<p>Pre-render certain pages, and render others on demand.</p>\n<p><img src=\"../../../images/perf-incremental-static-regeneration.png\" alt=\"Performance of Incremental Static Regeneration\"></p>\n<p>✅ Static benefits.\n⚠️ Server costs</p>\n<h2>Server-side rendering</h2>\n<p>With server-side rendering, we can generate HTML on the server on every request.</p>\n<p><img src=\"../../../images/perf-server-side-rendering.png\" alt=\"Performance of Server-side Rendering\"></p>\n<p>✅ Personalized pages.\n✅ Render blocking.\n⚠️ Initial load. Optimize with db queries and cache control.\n⚠️ Availability. If a region goes down, so does your website.</p>\n<h3>Streaming server-side rendering</h3>\n<p>Generate HTML on every request, sending it down piece by piece</p>\n<p><img src=\"../../../images/perf-streaming-server-side-rendering.png\" alt=\"Performance of Streaming Server-side Rendering\"></p>\n<p>✅  Performance regardless of the page size.\n✅ Network backpressure.\n⚠️ Support. Not all runtimes support HTTP streaming.</p>","frontmatter":{"date":"February 11, 2022","title":"FEM A Tour of JS Patterns","tags":["workshop","front-end-masters"]}}},"pageContext":{"slug":"/workshops/fem/fem-tour-js-patterns/"}},
    "staticQueryHashes": ["1929983096","3649515864"]}