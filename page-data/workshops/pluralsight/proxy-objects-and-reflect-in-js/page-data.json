{"componentChunkName":"component---src-templates-note-template-tsx","path":"/workshops/pluralsight/proxy-objects-and-reflect-in-js/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://app.pluralsight.com/library/courses/javascript-proxy-objects-reflect/table-of-contents\">https://app.pluralsight.com/library/courses/javascript-proxy-objects-reflect/table-of-contents</a></p>\n<p><a href=\"https://replit.com/@kaltepeter/pluralsight-proxy-objects#index.js\">https://replit.com/@kaltepeter/pluralsight-proxy-objects#index.js</a></p>\n<h2>Proxy Objects</h2>\n<ul>\n<li>Must provide a handler or you get: <code>TypeError: Cannot create proxy with a non-object as target or handler</code></li>\n<li>Targets also must be objects</li>\n<li><code>const custProxy = new Proxy(customer, {});</code> would create a proxy with no special handling.</li>\n<li>Handler set trap must return true if successful. If failed throw an exception, don't return false</li>\n<li>When using arrow functions args are symbols</li>\n</ul>\n<p>Simple example.</p>\n<pre><code class=\"language-javascript\">const customer = {\n    firstName: \"\",\n    lastName: \"\",\n    phone: \"\",\n    companyName: \"\",\n};\n\nconst handler = {\n    set(target, prop, val) {\n        out(`Setting ${prop} - ${val}`);\n        // if (prop === \"firstName\") {\n        target[prop] = val;\n        // }\n        return true;\n    },\n};\n\nconst custProxy = new Proxy(customer, handler);\ncustProxy.firstName = \"Shawn\";\ncustProxy.lastName = \"Wildermuth\";\n</code></pre>\n<h2>What Can Be Proxied</h2>\n<p>Only objects.</p>\n<ul>\n<li>❌ number</li>\n<li>❌ boolean</li>\n<li>❌ string</li>\n<li>❌ null</li>\n<li>❌ undefined</li>\n<li>❌ symbol</li>\n<li>✅ object</li>\n<li>✅ array</li>\n<li>✅ date</li>\n<li>✅ set</li>\n<li>✅ map</li>\n</ul>\n<h2>Traps</h2>\n<ul>\n<li>Object level middleware.</li>\n<li>Allows you to opt-into take responsibility for operations</li>\n<li>You can trap operations, not properties</li>\n</ul>\n<h3>Use Cases</h3>\n<ul>\n<li>Validation</li>\n<li>Notification of property changes</li>\n<li>Auditing</li>\n<li>Often used for reactivity</li>\n</ul>\n<h2>Functions</h2>\n<p>Use the apply trap to wrap a function.</p>\n<pre><code class=\"language-javascript\">const formatCustomer = (cust) => {\n    return `${cust.lastName}, ${cust.firstName}`;\n};\n\nconst formatProxy = new Proxy(formatCustomer, {\n    apply: (target, thisArg, args) => {\n        out(`Calling ${target}`);\n        return target.apply(thisArg, args);\n    },\n});\n\nout(formatProxy(custProxy));\n</code></pre>\n<h2>Iteration</h2>\n<h3>Arrays</h3>\n<ul>\n<li>Still objects</li>\n<li>multiple traps may be needed</li>\n<li>array proxy doesn't wrap items, the keys printed are things like foreach, length, or the item index</li>\n</ul>\n<pre><code class=\"language-javascript\">   const people = [\n        {\n            name: \"Shawn\",\n            age: 50,\n        },\n        {\n            name: \"James\",\n            age: 44,\n        },\n        {\n            name: \"Betty\",\n            age: 29,\n        },\n        {\n            name: \"Phillip\",\n            age: 88,\n        },\n    ];\n\n    const proxyCollection = new Proxy(people, {\n        get: (target, key) => {\n            out(`Key: ${key}`);\n            if (key === \"pop\") throw Error(\"pop is not allowed\");\n            return target[key];\n        },\n        set: (target, key, value) => {\n            if (key &#x3C; target.length) {\n                throw new Error(\"Cannot assign existing items\");\n            }\n            return (target[key] = value);\n        },\n    });\n\n    proxyCollection.forEach((c) => {\n        out(`foreach: ${c.name}`);\n    });\n\n    // proxyCollection.splice(1, 1, { name: \"Bob\" });\n</code></pre>\n<h3>Objects</h3>\n<pre><code class=\"language-javascript\">    const customer = {\n        firstname: \"Shawn\",\n        lastname: \"Wildermuth\",\n        phone: \"4045551212\",\n        companyname: \"Wilder Minds\",\n        _id: 100,\n    };\n\n    const proxyCust = new Proxy(customer, {\n        ownKeys: (target) => {\n            return Object.keys(target).filter((k) => k[0] !== \"_\");\n        },\n        get: (target, key) => {\n            if (key[0] === \"_\") {\n                return;\n            }\n            return target[key];\n        },\n        set: (target, key, value) => {\n            if (key[0] === \"_\") {\n                throw Error(`Could not find ${key} in object`);\n            }\n            return (target[key] = value);\n        },\n        has: (target, key) => {\n            if (key[0] === \"_\") {\n                return false;\n            }\n            return key in target;\n        },\n    });\n\n    for (let key in proxyCust) {\n        out(key);\n        out(customer[key]);\n    }\n\n    out(proxyCust._id);\n    // proxyCust._id = 101;\n\n    if (\"_id\" in proxyCust) {\n        out(\"Found\");\n    }\n</code></pre>\n<h3>Nested Proxies</h3>\n<ul>\n<li>you can return proxies from getters</li>\n<li>proxies can be slow</li>\n</ul>\n<pre><code class=\"language-javascript\">get: (target, key) => {\n    out(`Key is ${key}`);\n    if (key[0] === \"_\") {\n        return;\n    }\n    return new Proxy(target[key], {\n        get: (t, k) => {\n            out(`nested: ${k}`);\n            return t[k];\n        },\n    });\n},\n</code></pre>\n<h2>Proxies in Action</h2>\n<ul>\n<li>you can create a proxy for a class</li>\n<li>this is for the 'type'</li>\n<li>basically a constructor function</li>\n<li>key is a construct trap</li>\n</ul>\n<h3>Classes</h3>\n<pre><code class=\"language-javascript\">import out from \"./out.js\";\nimport Order from \"./order.js\";\n\nexport const classes = () => {\n    out(\"Starting classes...\\n\");\n\n    const classProxy = new Proxy(Order, {\n        construct: (target, args) => {\n            out(`calling constructor`);\n            return new Proxy(new target(...args), {\n                get: (target, key) => {\n                    out(`getting ${key}`);\n                    return target[key];\n                },\n            });\n        },\n    });\n    const order = new classProxy(1001, 1, \"Net 30\");\n    out(order.terms);\n\n    out(\"Ending classes...\\n\\n\");\n};\n\nexport default classes;\n</code></pre>\n<p>DefineProperty trap can handle setting unknowns, etc. This will not work if a set if defined because it's the same thing.</p>\n<p>In this example the defineProperty trap is not hit.</p>\n<pre><code class=\"language-javascript\">    set: (target, key, value) => {\n        return (target[key] = value);\n    },\n    defineProperty: (target, key, desc) => {\n        if (key.indexOf(\"_\") > -1) {\n            throw new Error(\"Cannot define properties with _\");\n        }\n        out(`Defining property ${key}`);\n        return true\n    },\n</code></pre>\n<p>If you need to protect property names and set, do it all in defineProperty.</p>\n<pre><code class=\"language-javascript\">defineProperty: (target, key, desc) => {\n    if (key.indexOf(\"_\") > -1) {\n        throw new Error(\"Cannot define properties with _\");\n    }\n    out(`Defining property ${key}`);\n    return target[key] = desc.value; // same as return true\n},\n</code></pre>\n<h4>delete trap</h4>\n<pre><code class=\"language-javascript\">deleteProperty: (target, key) => {\n    if (key === \"age\") {\n        throw new Error(\"Cannot delete age\");\n    }\n    delete target[key];\n    return true;\n},\n</code></pre>\n<h4>prevent extensibility</h4>\n<pre><code class=\"language-javascript\">isExtensible: (target) => {\n    out(`testing extensibility`);\n    return Object.isExtensible(target);\n},\npreventExtensions: (target) => {\n    out(`Locking down object`);\n    return Object.preventExtensions(target);\n},\n</code></pre>\n<h3>throttling functions</h3>\n<pre><code class=\"language-javascript\">const checkUpdates = () => {\n    out(`Fetching`);\n    return true;\n};\n\nlet lastTime = 0;\nlet cached = false;\n\nconst funcProxy = new Proxy(checkUpdates, {\n    apply: (target, theThis, args) => {\n        const newTime = new Date().getTime();\n        if (newTime - lastTime > 1000) {\n            cached = target.apply(theThis, args);\n            lastTime = newTime;\n        }\n        return cached;\n    },\n});\n\nwhile (true) {\n    funcProxy();\n}\n</code></pre>\n<h3>async throttling function</h3>\n<pre><code class=\"language-javascript\"> const checkUpdates = async () => {\n    out(`Fetching`);\n    try {\n        const result = await fetch(`https://catfact.ninja/fact`);\n        const { fact } = await result.json();\n        return fact;\n    } catch (e) {\n        out(e);\n    }\n    return true;\n};\n\nlet lastTime = 0;\nlet cached = false;\n\nconst funcProxy = new Proxy(checkUpdates, {\n    apply: async (target, theThis, args) => {\n        const newTime = new Date().getTime();\n        if (newTime - lastTime > 1000) {\n            cached = await target.apply(theThis, args);\n            lastTime = newTime;\n            out(cached);\n        }\n        return cached;\n    },\n});\n\nwhile (true) {\n    await funcProxy();\n}\n</code></pre>\n<h3>revocable proxies</h3>\n<p>For short term use, one way call.</p>\n<pre><code class=\"language-javascript\">const some = {\n    name: \"Shawn\",\n    city: \"Atlanta\",\n};\n\nconst someProxy = Proxy.revocable(some, {\n    get: (target, key) => {\n        if (key === \"name\") return target[key].toUpperCase();\n        return target[key];\n    },\n});\n\nout(`${someProxy.proxy.name} from ${someProxy.proxy.city}`);\nsomeProxy.revoke();\n// out(`${someProxy.proxy.name} from ${someProxy.proxy.city}`); # throw error\nout(`${someProxy.name} from ${someProxy.city}`);\nout(`${some.name} from ${some.city}`);\n</code></pre>\n<h3>Limitations of Proxies</h3>\n<ul>\n<li>Browser support. Incomplete poly-fill for older browsers</li>\n<li>Not able to detect a proxy</li>\n<li>Can be a drag on performance</li>\n</ul>\n<h2>Reflect API</h2>\n<ul>\n<li>static object</li>\n<li>API for performing proxy operations</li>\n<li>Does not require a proxy</li>\n<li>Mirrors the Handler</li>\n<li>Very little use outside proxy</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/notes/static/f678b7a9373553864795daee6f1614ad/393aa/pluralsight-js-reflection-api.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.06748466257669%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAACZ0lEQVR42pVV7XKiQBD0ARJFifINoqjIhyKIioJR73I/ru7e/3E6M6ukclU5UvwYZxG3t2eme+1I3QDSs49+dylCelpA4kzf8bt+L2wVneFoC929QbEqqFYJw/8NM/gDxSyhDhMYWtYOUOpFmHknZJsfmExKOG4F3djDHZ8wlFeQ+3FLwCcfmlVglvzFZFzANnJoygausxeAvedlO0DeMLZz7HZviIIzARUw9S2BpnCsPV4GcateEmAA186wy67wZxUccwddzeiQAuoowUCKREjdUMS3gF1iOBnnyNMLgvkR2/SKVVQhTV4RLU90SAmL2sCHGNqW2OdgEo0MGTDbXLCOSiTxWUSWXBAujpjTwBiwBuN1Uws6/FJXE4TEJvBP8NwdQr8U/WMQdbSh9YF6uRIbuPzGkvkHo5c1FNLc5xc1i7qH3wF9ADIDmwbR1hGNJUvPbLVHpufP2mtrv45M4h2qKV6IqSyvqfwVaTARDuFgHbYCVN0CTvoLdnSFMa9o0mfs85/QH1NlobdxS0chi1nxDaZ/huaVmE8P2JKEpu5BXAxjey+Gdh9Q+E/+L6BJgAYBqlMS8rzAIb9hMTt9iFlTMsGy7mejDhV7Rwyvd4YEyAxzcotj5ZhN6dKYFNBGawLfCE0OpPiRo+9LVqdHLMkd2foVq7Akt7wipTXbkl20INewXudeJdrwFdOOOj7ATt5ghTSURSVKzqmHOVkvDk7C2wvvCI+YepOjmDy3gvOXgCwXjcoeaqmQj0rlOVYGk54tPRWlyn2Slnx3E/89NF4OA/oYsk8fAu9R7j7dN9VRD6IJqAZ8B7dyO0IQwFEfAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Reflect API\"\n        title=\"\"\n        src=\"/notes/static/f678b7a9373553864795daee6f1614ad/a6d36/pluralsight-js-reflection-api.png\"\n        srcset=\"/notes/static/f678b7a9373553864795daee6f1614ad/222b7/pluralsight-js-reflection-api.png 163w,\n/notes/static/f678b7a9373553864795daee6f1614ad/ff46a/pluralsight-js-reflection-api.png 325w,\n/notes/static/f678b7a9373553864795daee6f1614ad/a6d36/pluralsight-js-reflection-api.png 650w,\n/notes/static/f678b7a9373553864795daee6f1614ad/e548f/pluralsight-js-reflection-api.png 975w,\n/notes/static/f678b7a9373553864795daee6f1614ad/393aa/pluralsight-js-reflection-api.png 1190w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code class=\"language-javascript\">const person = {\n    name: \"Shawn\",\n};\n\nReflect.set(person, \"name\", \"Bob\");\nout(Reflect.get(person, \"name\"));\n</code></pre>\n<pre><code class=\"language-javascript\">const theOrder = new Proxy(order, {\n    get: (target, key) => {\n        out(`reading a property: ${key}`);\n        return Reflect.get(target, key);\n    },\n});\n\nout(theOrder.orderNumber);\n\nconst theOrder = new Proxy(order, {\n    get() {\n        const result = Reflect.get(...arguments);\n        out(`reading a property: ${result}`);\n        return result;\n    },\n    set() {\n        return Reflect.set(...arguments);\n    },\n    apply() {\n        return Reflect.apply(...arguments);\n    },\n    defineProperty() {\n        return Reflect.defineProperty(...arguments);\n    },\n});\n\ntheOrder.orderNumber = 1002;\nout(theOrder.orderNumber);\n</code></pre>","frontmatter":{"date":"April 26, 2024","title":"Proxy Objects and Reflect in JavaScript","tags":["course","pluralsight","javascript"]}}},"pageContext":{"slug":"/workshops/pluralsight/proxy-objects-and-reflect-in-js/"}},"staticQueryHashes":["1796642556","2356112386","3489759178"],"slicesMap":{}}