{"componentChunkName":"component---src-templates-note-template-tsx","path":"/workshops/real-python/create-tic-tac-toe-python-game/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://realpython.com/videos/python-tic-tac-toe-ai-overview/\">https://realpython.com/videos/python-tic-tac-toe-ai-overview/</a></p>\n<h2>Setup</h2>\n<pre><code class=\"language-bash\">mkdir tic-tac-toe &#x26;&#x26; cd $_\npython -m venv venv\nsource venv/bin/activate\npython -m pip install --editable library/\n</code></pre>\n<h2>Modeling</h2>\n<pre><code class=\"language-python\">from __future__ import annotations\n</code></pre>\n<ul>\n<li>avoid circular reference</li>\n<li>lazy type hinting</li>\n</ul>\n<pre><code class=\"language-python\">>>> from tic_tac_toe.logic.models import Mark\n>>> Mark.CROSS\n&#x3C;Mark.CROSS: 'X'>\n>>> Mark.NAUGHT\n&#x3C;Mark.NAUGHT: 'O'>\n>>> Mark['CROSS']\n&#x3C;Mark.CROSS: 'X'>\n>>> Mark['NAUGHT']\n&#x3C;Mark.NAUGHT: 'O'>\n>>> Mark(\"X\")\n&#x3C;Mark.CROSS: 'X'>\n>>> Mark(\"O\")\n&#x3C;Mark.NAUGHT: 'O'>\n>>> Mark(\"X\").other\n&#x3C;Mark.NAUGHT: 'O'>\n>>> Mark(\"X\").other\n&#x3C;Mark.NAUGHT: 'O'>\n>>> Mark(\"X\").name\n'CROSS'\n>>> Mark(\"X\").value\n'X'\n>>> Mark(\"X\") == \"X\"\nTrue\n>>> is_instance(Mark.CROSS, str)\nTraceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\nNameError: name 'is_instance' is not defined. Did you mean: 'isinstance'?\n>>> isinstance(Mark.CROSS, str)\nTrue\n>>> Mark.CROSS.lower()\n'x'\n>>> for mark in Mark:\n...     print(mark)\n... \nX\nO\n\n>>> def preview(cells):\n...     print(cells[:3], cells[3:6], cells[6:], sep='\\n')\n... \n>>> preview('OXOOXXXOX')\nOXO\nOXX\nXOX\n</code></pre>\n<h3>Immutable Classes</h3>\n<ul>\n<li>fault tolerance</li>\n<li>imoproved code readability</li>\n</ul>\n<pre><code class=\"language-python\">@dataclass(frozen=True)\nclass Grid:\n    cells: str = \" \" * 9\n</code></pre>\n<h3>Dataclasses</h3>\n<ul>\n<li>control object initialization</li>\n<li>allow post-initialization hook:\n<ul>\n<li>set derived propperties</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">def __post_init__(self) -> None:\n    if not re.match(r\"^[\\sXO]{9}$\", self.cells):\n        raise ValueError(\"Must contain 9 cells of: X, O, or space\")\n\n @cached_property\n    def x_count(self) -> int:\n        return self.cells.count(Mark.CROSS)\n</code></pre>\n<h2>When to refactor?</h2>\n<ul>\n<li>3 uses of code</li>\n</ul>\n<h2>Separate Validation Layer</h2>\n<ul>\n<li>validation in domain model violates the single responsibility principle</li>\n<li>invalid states are possible</li>\n<li>GameState should fail when invalid</li>\n<li>validation belongs to a separate module</li>\n</ul>\n<h2>Circular Dependencies</h2>\n<ul>\n<li>python reads dependencies top-down</li>\n<li>importing bi-directional will cause an error</li>\n<li>common problem with type hints</li>\n<li>declare type hints in quotes to avoid error</li>\n</ul>\n<pre><code class=\"language-python\">Traceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\n  File \"/Users/ripley/data/ka/tutorials/tic-tac-toe/library/src/tic_tac_toe/logic/models.py\", line 7, in &#x3C;module>\n    from tic_tac_toe.logic.validators import validate_grid\n  File \"/Users/ripley/data/ka/tutorials/tic-tac-toe/library/src/tic_tac_toe/logic/validators.py\", line 3, in &#x3C;module>\n    from tic_tac_toe.logic.models import Grid\nImportError: cannot import name 'Grid' from partially initialized module 'tic_tac_toe.logic.models' (most likely due to a circular import) (/Users/ripley/data/ka/tutorials/tic-tac-toe/library/src/tic_tac_toe/logic/models.py)\n</code></pre>\n<p>Use future to wrap with <code>TYPE_CHECKING</code> to fix the issue</p>\n<ul>\n<li>avoids circular import</li>\n<li>tools like mypy can use this to check type hints otherwise skip import</li>\n</ul>\n<pre><code class=\"language-python\">from __future__ import annotations\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from tic_tac_toe.logic.models import Grid\n</code></pre>\n<h2><code>__future__</code> import</h2>\n<ul>\n<li>originally for the python 2 to 3 transition</li>\n<li>allows features from future releases to be used</li>\n<li>import can be removed when feature included</li>\n</ul>\n<h2>Exceptions</h2>\n<ul>\n<li>extend <code>Exception</code></li>\n<li>adding docstring avoids pass or other things</li>\n<li>empty class that conveys info</li>\n</ul>\n<pre><code class=\"language-python\">class InvalidGameState(Exception):\n   \"\"\"Raised when the game state is invalid.\"\"\"\n</code></pre>\n<h2>Error Handler</h2>\n<p>Let the frontend handle errors</p>\n<pre><code class=\"language-python\">from typing import Callable, TypeAlias\nErrorHandler: TypeAlias = Callable[[Exception], None]\n\n@dataclass(frozen=True)\nclass TicTacToe:\n    player1: Player\n    player2: Player\n    renderer: Renderer\n    error_handler: ErrorHandler | None = None\n\n    def play(self, starting_mark: Mark = Mark.CROSS) -> None:\n        game_state = GameState(Grid(), starting_mark)\n        while True:\n            self.renderer.render(game_state)\n            if game_state.game_over:\n                break\n\n            player = self.get_current_player(game_state)\n\n            try:\n                game_state = player.make_move(game_state)\n            except InvalidMove as ex:\n                if self.error_handler:\n                    self.error_handler(ex)\n</code></pre>\n<h2>Abstract Classes</h2>\n<p>Extend <code>abc.ABC</code>, <code>abc.ABCMeta</code>, or <code>abc.ABCAncestor</code></p>\n<p>Using the <code>metaclass</code> argument</p>\n<ul>\n<li>more flexible\n<ul>\n<li>doesn't affect inheritance hierarchy</li>\n<li>less important in python with multiple inheritance</li>\n</ul>\n</li>\n<li>favor composition over inheritance when possible</li>\n</ul>\n<pre><code class=\"language-python\">import abc\n\nfrom tic_tac_toe.logic.models import Mark\n\n\nclass Player(metaclass=abc.ABCMeta):\n    def __init__(self, mark: Mark) -> None:\n        self.mark = mark\n\n# must implement in concrete subclasses, template method pattern\n    @abc.abstractmethod\n    def get_move(self, game_state: GameState) -> Move | None:\n        \"\"\"REturn the current player's move in the given game state.\"\"\"\n</code></pre>\n<p><code>:=</code> walrus operator, assigns a value to a variable as part of an expression</p>\n<p>Extending an abstract class</p>\n<pre><code class=\"language-python\">class ComputerPlayer(Player, metaclass=abc.ABCMeta):\n    def __init__(self, mark: Mark, delay_seconds: float = 0.25) -> None:\n        super().__init__(mark)\n        self.delay_seconds = delay_seconds\n\n    def get_move(self, game_state: GameState) -> Move | None:\n        time.sleep(self.delay_seconds)\n        return self.get_computer_move(game_state)\n    \n    @abc.abstractmethod\n    def get_computer_move(self, game_state: GameState) -> Move | None:\n        \"\"\"Return the computer's move in the given game state.\"\"\"\n\n\nclass RandomComputerPlayer(ComputerPlayer):\n    def get_computer_move(self, game_state: GameState) -> Move | None:\n        try:\n            return random.choice(game_state.possible_moves)\n        except IndexError:\n            return None\n</code></pre>\n<h2>Classes vs. Functions</h2>\n<p>A class with a single method could be a function. If you have abstract classes that need to contribute to state, it makes more sense to use a class.</p>\n<h2>UI</h2>\n<p><code>\\N{party popper}</code> print emoji</p>\n<pre><code class=\"language-python\">import textwrap\n\n print(\n        textwrap.dedent(\n            \"\"\"\\\n             A   B   C\n           ------------\n        1 ┆  {0} │ {1} │ {2}\n          ┆ ───┼───┼───\n        2 ┆  {3} │ {4} │ {5}\n          ┆ ───┼───┼───\n        3 ┆  {6} │ {7} │ {8}\n    \"\"\"\n        ).format(*cells)\n    )\n</code></pre>\n<h2>Handling Exceptions</h2>\n<p>Try has optional <code>else</code> which is executed if no exception is raised</p>\n<pre><code class=\"language-python\">try:\n    index = grid_to_index(input(f\"{self.mark}'s move: \").strip())\nexcept ValueError:\n    print(\"Please provide coordinates in teh for of A1 or 1A\")\nelse:\n    print(\"no error\")\n</code></pre>\n<h2>Named Tuple</h2>\n<ul>\n<li>additional type safety</li>\n<li>access to arguments by name and index</li>\n</ul>\n<pre><code class=\"language-python\">from typing import NamedTuple\n\nclass Args(NamedTuple):\n    player1: Player\n    player2: Player\n    starting_mark: Mark\n\n# def parse_args() -> tuple[Player, Player, Mark]:\ndef parse_args() -> Args:\n\n    #  return player1, player2, args.starting_mark\n    return Args(player1, player2, args.starting_mark)\n\n</code></pre>\n<h2>AI</h2>\n<ul>\n<li>computer player</li>\n<li>basic AI</li>\n<li>use minimax algorithm\n<ul>\n<li>optimal move in any situation</li>\n<li><a href=\"https://realpython.com/python-minimax-nim/\">https://realpython.com/python-minimax-nim/</a></li>\n</ul>\n</li>\n</ul>\n<h3>Minimax Algorithm Requirements</h3>\n<ul>\n<li>scoring system needed\n<ul>\n<li>allows choice of best move</li>\n<li>absolute scale of numeric values</li>\n</ul>\n</li>\n<li>static evaluation of game\n<ul>\n<li>player looses: <code>-1</code></li>\n<li>player ties: <code>0</code></li>\n<li>player wins: <code>1</code></li>\n</ul>\n</li>\n<li>protagonist:\n<ul>\n<li>maximizing player</li>\n</ul>\n</li>\n<li>opponent:\n<ul>\n<li>minimizing player</li>\n</ul>\n</li>\n<li>desirable outcomes:\n<ul>\n<li>choiced of best move for increased score</li>\n<li>avoidance of opononent's increased score</li>\n</ul>\n</li>\n<li>minimax:\n<ul>\n<li>minimize opponent's maximum gain</li>\n<li>maximize your minimum gain</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">>>> from tic_tac_toe.logic.minimax import minimax\n>>> from tic_tac_toe.logic.models import GameState, Grid, Mark\n>>> \n>>> def preview(cells):\n...     print(cells[:3], cells[3:6], cells[6:], sep=\"\\n\")\n... \n>>> game_state = GameState(Grid(\"XXO O X O\"), starting_mark=Mark(\"X\"))\n>>> for move in game_state.possible_moves:\n...     print(\"Score:\", minimax(move, maximizer=Mark(\"X\")))\n...     preview(move.after_state.grid.cells)\n...     print(\"-\" * 10)\n... \nScore: 1\nXXO\nXO \nX O\n----------\nScore: 0\nXXO\n OX\nX O\n----------\nScore: -1\nXXO\n O \nXXO\n----------\n</code></pre>\n<h2>Minimax Algorithm</h2>\n<ul>\n<li>calculates score for a given move</li>\n<li>to find the best possible move:\n<ul>\n<li>sort all by score</li>\n<li>take highest-value move</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">def find_best_move(game_state: GameState) -> Move | None:\n    maximizer: Mark = game_state.current_mark\n    bound_minimax = partial(minimax, maximizer=maximizer)\n    return max(game_state.possible_moves, key=bound_minimax)\n</code></pre>\n<p>Partial freezes the maximizer across invocations.</p>\n<p><code>functools.partial</code></p>\n<ul>\n<li>factory:\n<ul>\n<li>produces a new function with fewer parameters</li>\n<li>prepopulates the original function with concrete values</li>\n<li>performed dynamically at runtime</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"May 18, 2025","title":"Create a Tic-Tac-Toe Python Game Engine With an AI Player","tags":["course","real-python","python","game"]}}},"pageContext":{"slug":"/workshops/real-python/create-tic-tac-toe-python-game/"}},"staticQueryHashes":["1796642556","2356112386","3489759178"],"slicesMap":{}}