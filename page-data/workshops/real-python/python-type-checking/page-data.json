{"componentChunkName":"component---src-templates-note-template-tsx","path":"/workshops/real-python/python-type-checking/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://realpython.com/videos/python-type-checking-overview/\">https://realpython.com/videos/python-type-checking-overview/</a></p>\n<h2>Dynamic vs. Static Typing</h2>\n<h3>Dynamic Typing</h3>\n<ul>\n<li>Type checking is performed at runtime</li>\n<li>The type of a variable can change over its lifetime</li>\n</ul>\n<pre><code class=\"language-python\">if False:\n    print(1 + \"two\") # never run\nelse:\n    print(1 + 2)\n\n# 3\n\n1 + \"two\"\n# Traceback (most recent call last):\n#   File \"/Users/kayla.altepeter/data/ka/notes/course.py\", line 6, in &#x3C;module>\n#     1 + \"two\"\n#     ~~^~~~~~~\n# TypeError: unsupported operand type(s) for +: 'int' and 'str'\n\nthing = \"Hello World\"\ntype(thing)\n# &#x3C;class 'str'>\n\nthing = 28.1\ntype(thing)\n# &#x3C;class 'float'>\n</code></pre>\n<h3>Static Typing</h3>\n<ul>\n<li>Type checking is performed at compile time</li>\n<li>The type of a variable cannot change over its lifetime\n<ul>\n<li>Exception: casting to another type</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">public class HelloTypes {\n    public static void main(String[] args) {\n        String thing;\n        thing = \"Hello, World!\";\n\n        // thing = 42;\n\n        System.out.println(thing);\n    }\n}\n</code></pre>\n<p><code>javac HelloTypes.java</code>\n<code>java HelloTypes</code></p>\n<h2>Duck Typing</h2>\n<p>If it walks like a duck and quacks like a duck, then it must be a duck.</p>\n<ul>\n<li>the type of the class of an objecrt is less important than the methods it defines</li>\n<li>instead of checking for the class or type, check the object for the presence of specific methods and/or attributes</li>\n</ul>\n<pre><code class=\"language-python\">class TheHobbit:\n    def __len__(self):\n        return 95022\n\nthe_hobbit = TheHobbit()\nthe_hobbit\n# &#x3C;__main__.TheHobbit object at 0x10441bd70>\nlen(the_hobbit)\n# 95022\ndef len(obj):\n    return obj.__len__()\n\nmy_str = \"Hello World\"\nmy_list = [34, 54, 65, 78]\nmy_dict = {\"one\": 123, \"two\": 456, \"three\": 789}\nlen(my_str)\n# 11\nlen(my_list)\n# 4\nlen(the_hobbit)\n# 95022\nmy_int = 7\nmy_float = 42.3\nlen(my_int)\n# Traceback (most recent call last):\n#   File \"&#x3C;stdin>\", line 1, in &#x3C;module>\n#   File \"&#x3C;stdin>\", line 2, in len\n# AttributeError: 'int' object has no attribute '__len__'. Did you mean: '__le__'?\nlen(my_float)\n# Traceback (most recent call last):\n#   File \"&#x3C;stdin>\", line 1, in &#x3C;module>\n#   File \"&#x3C;stdin>\", line 2, in len\n# AttributeError: 'float' object has no attribute '__len__'. Did you mean: '__le__'?\n</code></pre>\n<h2>Type Hinting</h2>\n<p>Statically indicate a type of a value</p>\n<ul>\n<li>specified in PEP 484</li>\n<li>python 3.5+</li>\n<li>annotate the arguments and return value for a function</li>\n</ul>\n<p>PEP 8</p>\n<ul>\n<li>Use normal colon rules, no space before and one space after\n<ul>\n<li><code>test: str</code></li>\n</ul>\n</li>\n<li>use spaces around the = sign when combining an argument annotation with a default value\n<ul>\n<li><code>align: bool = True</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">def headline(text, align=True):\n    if align:\n        return f\"{text.title()}\\n{'-' * len(text)}\"\n    else:\n        return f\" {text.title()} \".center(50, \"o\")\n\nprint(headline('python type checking'))\n# Python Type Checking\n# --------------------\nprint(headline('python type checking', align=False))\n# oooooooooooooo Python Type Checking oooooooooooooo\n\ndef headline(text: str, align: bool = True) -> str:\n    if align:\n        return f\"{text.title()}\\n{'-' * len(text)}\"\n    else:\n        return f\" {text.title()} \".center(50, \"o\")\n\nheadline\n# &#x3C;function headline at 0x104707920>\nprint(headline('python type checking', align=\"left\"))\n# Python Type Checking\n# --------------------\n</code></pre>\n<h2>Mypy</h2>\n<p><a href=\"https://mypy-lang.org/\">https://mypy-lang.org/</a></p>\n<blockquote>\n<p>Mypy is an optional static type checker for Python that aims to combine the benefits of dynamic (or \"duck\") typing and static typing.\nMypy combines the expressive power and convenience of Python with a powerful type system and compile-time type checking. Mypy type checks standard Python programs; run them using any Python VM with basically no runtime overhead.\n-- <a href=\"https://mypy-lang.org/\">https://mypy-lang.org/</a></p>\n</blockquote>\n<ul>\n<li>Originally started as a stand alone version of python</li>\n<li>was rewritten to use annotations making it a static type checker for regular python code</li>\n</ul>\n<p><code>python -m pip install mypy</code></p>\n<pre><code class=\"language-python\"># headlines.py\ndef headline(text: str, align: bool = True) -> str:\n    if align:\n        return f\"{text.title()}\\n{'-' * len(text)}\"\n    else:\n        return f\" {text.title()} \".center(50, \"o\")\n    \n\nprint(headline(\"python type checking\"))\nprint(headline(\"python type checking\", align=\"center\"))\n\n# v2\ndef headline(text: str, centered: bool = False) -> str:\n    if not centered:\n        return f\"{text.title()}\\n{'-' * len(text)}\"\n    else:\n        return f\" {text.title()} \".center(50, \"o\")\n    \n\nprint(headline(\"python type checking\"))\nprint(headline(\"python type checking\", centered=True))\n</code></pre>\n<pre><code class=\"language-bash\">python -m mypy headlines.py\n# headlines.py:9: error: Argument \"align\" to \"headline\" has incompatible type \"str\"; expected \"bool\"  [arg-type]\n# Found 1 error in 1 file (checked 1 source file)\npython -m mypy headlines.py\n# Success: no issues found in 1 source file\n</code></pre>\n<h2>Pro/Con of Type Hints</h2>\n<h3>Pros</h3>\n<ul>\n<li>catch certain errors</li>\n<li>document your code\n<ul>\n<li>for yourself, but especially if sharing with a team or project</li>\n</ul>\n</li>\n<li>imporve the functionality of IDEs and linters\n<ul>\n<li>enhancing code completion and suggestions</li>\n</ul>\n</li>\n<li>build and maintain a cleaner architecture</li>\n</ul>\n<h3>Cons</h3>\n<ul>\n<li>take developer time and effort to add</li>\n<li>work best in modern python\n<ul>\n<li>annotations introduced in python 3</li>\n<li>variable annotations and postponed evaluatgion work best in 3.6 or 3.7</li>\n</ul>\n</li>\n<li>introduce a slight penalty in start-up time\n<ul>\n<li>load the typing module</li>\n</ul>\n</li>\n</ul>\n<h3>Not all or nothing</h3>\n<ul>\n<li>python supports gradual typing\n<ul>\n<li>introducing types gradually into your code</li>\n<li>code without typehints will be ignored by the checker</li>\n<li>add to critical components first</li>\n</ul>\n</li>\n<li>adding types will havve no effect on the running of your program</li>\n</ul>\n<h2>Annotations</h2>\n<ul>\n<li>introduced in python 3</li>\n<li>a way to associate artitrary expressions to function arguments and return values</li>\n<li>PEP 484 defined how to add type hints to your python code\n<ul>\n<li>the main way to add type hints is using annotations</li>\n<li>type checking is becoming more and more common, annotations should mainly be reserved for type hints</li>\n</ul>\n</li>\n</ul>\n<h3>Function Annotations</h3>\n<ul>\n<li>annotate the arguments and return value for a function</li>\n<li>syntax for arguments:\n<ul>\n<li><code>argument: annotation</code></li>\n</ul>\n</li>\n<li>syntax for return value:\n<ul>\n<li><code>-> annotation</code></li>\n</ul>\n</li>\n<li>annotations must be valid python expressions</li>\n</ul>\n<h3>Inspecting Annotations</h3>\n<p><code>__annotations__</code></p>\n<pre><code class=\"language-python\">import math\ndef circumference(radius: float) -> float:\n    return 2 * math.pi * radius\n\ncircumference.__annotations__\n# {'radius': &#x3C;class 'float'>, 'return': &#x3C;class 'float'>}\ncircumference(1.23)\n# 7.728317927830891\n</code></pre>\n<pre><code class=\"language-python\">import math\n\nreveal_type(math.pi)\n\nradius = 1\ncircumference = 2 * math.pi * radius\n\nreveal_locals()\n</code></pre>\n<pre><code class=\"language-bash\">python -m mypy reveal.py\n# reveal.py:3: note: Revealed type is \"builtins.float\"\n# reveal.py:8: note: Revealed local types are:\n# reveal.py:8: note:     circumference: builtins.float\n# reveal.py:8: note:     radius: builtins.int\n# Success: no issues found in 1 source file\n</code></pre>\n<h3>Variable Annotations</h3>\n<ul>\n<li>Defined in PEP 526 and introduced in python 3.6</li>\n<li>Same syntax as function arguments:\n<ul>\n<li><code>pi: float = 3.14159</code></li>\n</ul>\n</li>\n<li>annotations of variables are stored in the module level of the <code>__annotations__</code> dictionary</li>\n</ul>\n<pre><code class=\"language-python\">import math\n\npi: float = 3.142\ndef circumference(radius: float) -> float:\n    return 2 * math.pi * radius\n\ncircumference.__annotations__\n# {'radius': &#x3C;class 'float'>, 'return': &#x3C;class 'float'>}\n__annotations__\n# {'pi': &#x3C;class 'float'>}\ncircumference(1)\n# Traceback (most recent call last):\n#   File \"&#x3C;stdin>\", line 1, in &#x3C;module>\n#   File \"&#x3C;stdin>\", line 2, in circumference\n# NameError: name 'math' is not defined. Did you forget to import 'math'?\ncircumference(1)\n# 6.283185307179586\nnothing: str\n__annotations__\n# {'pi': &#x3C;class 'float'>, 'nothing': &#x3C;class 'str'>}\n</code></pre>\n<h2>Type Comments</h2>\n<p>For a function annotate the arguments and the return value</p>\n<pre><code class=\"language-python\">def func(arg):\n    # type: (str) -> str\n</code></pre>\n<p>For variables add the type comment on the same line</p>\n<pre><code class=\"language-python\">my_var = 10  # type: int\n</code></pre>\n<pre><code class=\"language-python\">def circumference(radius):\n    # type: (float) -> float\n    return 2 * math.pi * radius\n\ncircumference(4.5)\n# 28.274333882308138\ncircumference.__annotations__\n# {}\n</code></pre>\n<pre><code class=\"language-python\">def headline(text, width=80, fill_char='-'):\n    # type: (str, int, str) -> str\n    return f\" {text.title()} \".center(width, fill_char)\n\n\ndef headline2(\n        text,           # type: str\n        width=80,       # type: int\n        fill_char='-'   # type: str\n    ):                  # type: (...) -> str\n    return f\" {text.title()} \".center(width, fill_char)\n\n\nprint(headline(\"python type checking\", width=40))\n\nprint(headline(\"python type checking\", width=70))\n\nprint(headline(\"python type checking\", width=\"normal\"))\n# Traceback (most recent call last):\n#   File \"/Users/kayla.altepeter/data/ka/notes/headlines.py\", line 16, in &#x3C;module>\n#     print(headline(\"python type checking\", width=\"normal\"))\n#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n#   File \"/Users/kayla.altepeter/data/ka/notes/headlines.py\", line 3, in headline\n#     return f\" {text.title()} \".center(width, fill_char)\n#            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n# TypeError: 'str' object cannot be interpreted as an integer\npi = 3.142  # type: float\n</code></pre>\n<blockquote>\n<p>[!NOTE]\nUse annoations if you can and comments if you must.</p>\n</blockquote>\n<h2>Python Types</h2>\n<pre><code class=\"language-python\">name: str = \"Guido\"\npi: float = 3.142\ncentered: bool = False\nnames: list = [\"Guido\", \"Thomas\", \"Bobby\"]\nnames\n# ['Guido', 'Thomas', 'Bobby']\nversion: tuple = (3, 7, 1)\noptions: dict = {\"centered\": False, \"capitalize\": True}\ntype(names)\n# &#x3C;class 'list'>\ntype(names[2])\n# &#x3C;class 'str'>\n__annotations__\n# {'name': &#x3C;class 'str'>, 'pi': &#x3C;class 'float'>, 'centered': &#x3C;class 'bool'>, 'names': &#x3C;class 'list'>, 'version': &#x3C;class 'tuple'>, 'options': &#x3C;class 'dict'>}\nfrom typing import Dict, List, Tuple\nnames: List[str] = [\"Guido\", \"Thomas\", \"Bobby\"]\nversion: Tuple[int, int, int] = (3, 7, 1)\noptions: Dict[str, bool] = {\"centered\": False, \"capitalize\": True}\n__annotations__\n# {'name': &#x3C;class 'str'>, 'pi': &#x3C;class 'float'>, 'centered': &#x3C;class 'bool'>, 'names': typing.List[str], 'version': typing.Tuple[int, int, int], 'options': typing.Dict[str, bool]}\n</code></pre>\n<pre><code class=\"language-python\"># game.py\n\nimport random\n\nSUITS = \"♠ ♡ ♢ ♣\".split()\nRANKS = \"2 3 4 5 6 7 8 9 10 J Q K A\".split()\n\n\ndef create_deck(shuffle=False):\n    \"\"\"Create a new deck of 52 cards\"\"\"\n    deck = [(s, r) for r in RANKS for s in SUITS]\n    if shuffle:\n        random.shuffle(deck)\n    return deck\n\n\ndef deal_hands(deck):\n    \"\"\"Deal the cards in the deck into four hands\"\"\"\n    return (deck[0::4], deck[1::4], deck[2::4], deck[3::4])\n\n\ndef play():\n    \"\"\"Play a 4-player card game\"\"\"\n    deck = create_deck(shuffle=True)\n    names = \"P1 P2 P3 P4\".split()\n    hands = {n: h for n, h in zip(names, deal_hands(deck))}\n\n    for name, cards in hands.items():\n        card_str = \" \".join(f\"{s}{r}\" for (s, r) in cards)\n        print(f\"{name}: {card_str}\")\n\n\nif __name__ == \"__main__\":\n    play()\n</code></pre>\n<pre><code class=\"language-python\"># game.py\n\nimport random\nfrom typing import List, Tuple\n\nCard = Tuple[str, str]\nDeck = List[Card]\n\nSUITS = \"♠ ♡ ♢ ♣\".split()\nRANKS = \"2 3 4 5 6 7 8 9 10 J Q K A\".split()\n\n\ndef create_deck(shuffle: bool = False) -> Deck:\n    \"\"\"Create a new deck of 52 cards\"\"\"\n    deck = [(s, r) for r in RANKS for s in SUITS]\n    if shuffle:\n        random.shuffle(deck)\n    return deck\n\n\ndef deal_hands(deck: Deck) -> Tuple[Deck, Deck, Deck, Deck]:\n    \"\"\"Deal the cards in the deck into four hands\"\"\"\n    return (deck[0::4], deck[1::4], deck[2::4], deck[3::4])\n\n\ndef play():\n    \"\"\"Play a 4-player card game\"\"\"\n    deck = create_deck(shuffle=True)\n    names = \"P1 P2 P3 P4\".split()\n    hands = {n: h for n, h in zip(names, deal_hands(deck))}\n\n    for name, cards in hands.items():\n        card_str = \" \".join(f\"{s}{r}\" for (s, r) in cards)\n        print(f\"{name}: {card_str}\")\n\n\nif __name__ == \"__main__\":\n    play()\n</code></pre>\n<p><a href=\"https://github.com/python/typeshed\">https://github.com/python/typeshed</a></p>\n<p>There are several static type checkers available for Python, including:</p>\n<ul>\n<li>mypy</li>\n<li>Pyright</li>\n<li>Pyre</li>\n<li>pytype</li>\n</ul>","frontmatter":{"date":"May 16, 2025","title":"Python Type Checking","tags":["course","real-python","python"]}}},"pageContext":{"slug":"/workshops/real-python/python-type-checking/"}},"staticQueryHashes":["1796642556","2356112386","3489759178"],"slicesMap":{}}