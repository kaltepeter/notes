{"componentChunkName":"component---src-templates-note-template-tsx","path":"/golang/","result":{"data":{"markdownRemark":{"html":"<h2>Getting Started</h2>\n<ul>\n<li><a href=\"https://go.dev/doc/\">Getting Started</a></li>\n<li><a href=\"https://go.dev/doc/tutorial/create-module\">Creating a Module Tutorial</a> - Full walk-through of creating a module</li>\n<li><a href=\"https://go.dev/tour/list\">Interactive Walkthrough</a> - Online code REPL with instructions and detailed dive through the language</li>\n<li><a href=\"https://pkg.go.dev/std\">Standard Library Docs</a></li>\n<li><a href=\"https://blog.alexellis.io/golang-writing-unit-tests/\">Writing Unit Tests</a> - Basic guide on writing unit tests</li>\n<li><a href=\"https://go.dev/play/\">Playground</a></li>\n<li><a href=\"https://go.dev/doc/effective_go\">Effective GO</a> - Guide on writing clear idiomatic code</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=golang.go\">VS Code Extension</a></li>\n<li><a href=\"https://gobyexample.com/\">Go By Example</a> - Really simple example code broken down by concept</li>\n<li><a href=\"https://medium.com/@BastianRob/implementing-reduce-in-go-4a3e6e3affc\">Example Reduce Function</a> - Blog on an example reduce function with reflection</li>\n<li><a href=\"https://golangbyexample.com/golang-comprehensive-tutorial/\">Advanced Tutorial</a> - More advanced comprehensive tutorial</li>\n<li><a href=\"https://golangbyexample.com/all-basic-data-types-golang/\">All Data Types</a> - Full list of data types, examples and when to use</li>\n<li><a href=\"https://golangdocs.com/\">Go Lang Docs</a> - Detailed posts and walk-through's on many topics</li>\n<li><a href=\"https://awesome-go.com/\">Awesome Go Libaries</a> - Curated list of libraries</li>\n<li><a href=\"https://go101.org/article/101.html\">Go 101</a> - Details about the language, online book</li>\n</ul>\n<h2>Installing</h2>\n<h3>Mac</h3>\n<pre><code class=\"language-bash\">brew install golang\n</code></pre>\n<h2>Enums</h2>\n<p>Go does not have enums. There are patterns that can be used. Mostly IOTA with Constants</p>\n<h2>Constants</h2>\n<p>Immutable values. Can be typed. Can't be declard with <code>:=</code></p>\n<pre><code class=\"language-Go\">const (\n    x int = 42\n    myString string = \"Hi\"\n)\n\nconst MY_CONST int = 3 * 7\n</code></pre>\n<h3>IOTA</h3>\n<p>An iota is an auto incrementing number that can only be used with constants. See <a href=\"https://golangbyexample.com/iota-in-golang/\">https://golangbyexample.com/iota-in-golang/</a> for full details</p>\n<pre><code class=\"language-Go\">const (\n    a = iota // 0\n    b // 1\n    c // 2\n)\n\ntype ByteSize float64\n\n// implicitly apply a function to get correct values\nconst (\n    _           = iota // ignore first value by assigning to blank identifier\n    KB ByteSize = 1 &#x3C;&#x3C; (10 * iota)\n    MB\n    GB\n    TB\n    PB\n    EB\n    ZB\n    YB\n)\n</code></pre>\n<h2>Functions</h2>\n<p>Go does not have default values. See <a href=\"https://joneisen.me/programming/2013/06/23/golang-and-default-values.html\">https://joneisen.me/programming/2013/06/23/golang-and-default-values.html</a> for options.</p>\n<p>Optional arguments: <a href=\"https://petomalina.medium.com/dealing-with-optional-parameters-in-go-9780f9bfbd1d\">https://petomalina.medium.com/dealing-with-optional-parameters-in-go-9780f9bfbd1d</a></p>\n<h2>Maps</h2>\n<p>Maps are unordered. See <a href=\"https://yourbasic.org/golang/how-to-sort-in-go/#bonus-sort-a-map-by-key-or-value\">https://yourbasic.org/golang/how-to-sort-in-go/#bonus-sort-a-map-by-key-or-value</a> for sorting. If you need a sorted list use arrays and slices</p>\n<h2>int vs inv64</h2>\n<p><code>int</code> is machine dependent, 32 bit is int32, 64 bit is int64</p>\n<p>Recommendation is to use int for signed values whenever possible, few exceptions</p>\n<h2>Slice to Array</h2>\n<p>This will give you compile time range checks and possibly improve performance if you know the array size.</p>\n<p><a href=\"https://stackoverflow.com/questions/19073769/how-do-you-convert-a-slice-into-an-array\">https://stackoverflow.com/questions/19073769/how-do-you-convert-a-slice-into-an-array</a></p>\n<p>Go 1.17</p>\n<pre><code class=\"language-go\">slice := []int{1,2,3,4,5,6}\narr := [6]int{}\narrPtr := (*[6]int)(slice)\narr = *arrPtr\n</code></pre>\n<p>Go 1.18+ will provide more</p>\n<h2>Data Conversions</h2>\n<h3>string to int</h3>\n<ul>\n<li><a href=\"https://golangdocs.com/converting-string-to-integer-in-golang\">https://golangdocs.com/converting-string-to-integer-in-golang</a></li>\n</ul>\n<pre><code class=\"language-Go\">import (\n    \"strconv\"\n)\n\nv := \"100\"\ni, _ := strconv.Atoi(v) // 100\nn, _ := strconv.ParseInt(v, 10, 0) // 100, equivalent to Atoi\n</code></pre>\n<h2>Bit Manipulation</h2>\n<ul>\n<li><a href=\"https://graphics.stanford.edu/~seander/bithacks.html\">Bit Hacks</a> - Large set of example bit manipulation</li>\n<li><a href=\"https://yourbasic.org/golang/bitwise-operator-cheat-sheet/\">Binary Operators Cheat Sheet</a> - Overview of binary operators</li>\n</ul>\n<h3>String to Decimal</h3>\n<pre><code class=\"language-Go\"></code></pre>\n<h2>Find in Array or Slice</h2>\n<p><a href=\"https://golangcode.com/check-if-element-exists-in-slice/\">https://golangcode.com/check-if-element-exists-in-slice/</a></p>\n<pre><code class=\"language-Go\">package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n\n    items := []string{\"A\", \"1\", \"B\", \"2\", \"C\", \"3\"}\n\n    // Missing Example\n    _, found := Find(items, \"golangcode.com\")\n    if !found {\n        fmt.Println(\"Value not found in slice\")\n    }\n\n    // Found example\n    k, found := Find(items, \"B\")\n    if !found {\n        fmt.Println(\"Value not found in slice\")\n    }\n    fmt.Printf(\"B found at key: %d\\n\", k)\n}\n\n// Find takes a slice and looks for an element in it. If found it will\n// return it's key, otherwise it will return -1 and a bool of false.\nfunc Find(slice []string, val string) (int, bool) {\n    for i, item := range slice {\n        if item == val {\n            return i, true\n        }\n    }\n    return -1, false\n}\n</code></pre>\n<h2>Filter slices</h2>\n<p><a href=\"https://zetcode.com/golang/filter-slice/\">https://zetcode.com/golang/filter-slice/</a></p>\n<h2>Functional Go</h2>\n<p><a href=\"https://deepu.tech/functional-programming-in-go/\">7 Basics of Functional Go</a>\n<a href=\"https://github.com/rbrahul/gofp/blob/master/collections.go\">gofp</a> - Inspired by lodash functional library</p>\n<h2>Testing</h2>\n<p><a href=\"https://ieftimov.com/post/testing-in-go-table-driven-tests/\">Table Driven Tests</a> - Examples of table driven tests</p>\n<h2>Debugging</h2>\n<p><a href=\"https://chetan177.medium.com/runtime-debugging-in-golang-b8a065d0fb5e\">Runtime Debugging</a> - Walkthorugh of delve</p>\n<pre><code class=\"language-bash\">go install github.com/go-delve/delve/cmd/dlv@latest\n</code></pre>\n<p>IDE's are easier to run.</p>\n<h2>Comparing Slices</h2>\n<p><a href=\"https://yourbasic.org/golang/compare-slices/\">https://yourbasic.org/golang/compare-slices/</a></p>\n<pre><code class=\"language-Go\">input := \"7,4,9,5,11,17\"\ngot := StringToListOfInt(input)\nwant := []int{7, 4, 9, 5, 11, 17}\nreflect.DeepEqual(got, want)\n</code></pre>\n<h2>Switch Statement</h2>\n<p><a href=\"https://golangdocs.com/switch-statement-in-golang\">https://golangdocs.com/switch-statement-in-golang</a></p>\n<h2>Graphs</h2>\n<p><a href=\"https://codetree.dev/golang-graph-traversal/\">https://codetree.dev/golang-graph-traversal/</a> - super easy walk through of basics</p>\n<h2>Stack</h2>\n<p><a href=\"https://flaviocopes.com/golang-data-structure-stack/\">https://flaviocopes.com/golang-data-structure-stack/</a> - example stack implementation</p>\n<p>List or slice is possible. Slice seems more idiomatic</p>\n<h2>Types</h2>\n<p>Go currently does not have generics. It does have duck typing and interfaces.</p>\n<h2>Printing type info</h2>\n<pre><code class=\"language-go\">func Println2(x interface{}) {\n    fmt.Printf(\"type is '%T', value: %v\\n\", x, x)\n}\n</code></pre>\n<h3>Using an Interface</h3>\n<ul>\n<li><a href=\"https://musse.dev/stringer-golang/\">https://musse.dev/stringer-golang/</a> Most used interface, great example</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype Dog struct {\n    name string\n    breed string\n}\n\nfunc (d *Dog) String() string {\n    return fmt.Sprintf(\"My name is %s, I'm a %s! Woof!\", d.name, d.breed)\n}\n\nfunc main() {\n    d := Dog{\"Rex\", \"poodle\"}\n    fmt.Print(d) // {Rex poodle}\n    fmt.Print(&#x26;d) // My name is Rex, I'm a poodle! Woof!\n}\n</code></pre>\n<p>More complex custom example:</p>\n<pre><code class=\"language-go\">func (p *Packet) String() string {\n return fmt.Sprintf(\"[Packet] Version: %v TypeId: %v Value: %v \\nSubPacket: %v\", p.Version, p.TypeId, p.Value, p.SubPacket)\n}\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"language-bash\">[Packet] Version: 3 TypeId: 0 Value: 10000000001000000000000000000101100001000101010110001011001000100000000010000100011000111000110100\nSubPacket: [Packet] Version: 0 TypeId: 0 Value: 00000000000101100001000101010110001011001000100000000010000100011000111000110100\nSubPacket: [Packet] Version: 0 TypeId: 4 Value: 01010101100010111010\nSubPacket: [Packet] Version: 5 TypeId: 4 Value: 010111011\nSubPacket: [Packet] Version: 0 TypeId: 0 Value:\nSubPacket: &#x3C;nil>\n</code></pre>\n<h3>Embedding a type in a type (Alternate to extension)</h3>\n<ul>\n<li><a href=\"https://medium.com/swlh/what-is-the-extension-interface-pattern-in-golang-ce852dcecaec\">https://medium.com/swlh/what-is-the-extension-interface-pattern-in-golang-ce852dcecaec</a></li>\n<li><a href=\"https://golangbyexample.com/embedding-interfaces-go/\">https://golangbyexample.com/embedding-interfaces-go/</a></li>\n</ul>\n<p>Called the extension interface pattern</p>\n<pre><code class=\"language-go\">type Packet struct {\n Version   int64\n TypeId    int64\n Value     string\n SubPacket *Packet\n}\n\ntype Bits struct {\n Packet\n}\n</code></pre>\n<p>This pattern allows recursion of the fields. All Packet fields are contained in Bits and each packet can reference a sub packet. Note, this is an anonymous inclusion and can be referenced by either direct value or <code>Packet.&#x3C;value></code> Name</p>\n<pre><code class=\"language-go\">bits := Bits{\n    Value: \"Yo\"\n    TypeId: 1,\n    Version: 2\n}\n\nfmt.Println(bits.Value) // \"Yo\"\nfmt.Println(bits.Packet.Value) // \"Yo\"\n</code></pre>\n<h2>Type Switching</h2>\n<p><a href=\"https://golangdocs.com/reflection-type-switching-in-golang\">https://golangdocs.com/reflection-type-switching-in-golang</a></p>\n<pre><code class=\"language-go\">func Println2(x interface{}) {\n    switch x.(type) {\n    case bool:\n        fmt.Print(\"This is a boolean value: \", x.(bool))\n    case int:\n        fmt.Print(\"This is my nice int value: \", x.(int))\n    case float64:\n        fmt.Print(x.(float64))\n    case complex128:\n        fmt.Print(x.(complex128))\n    case string:\n        fmt.Print(x.(string))\n    case Person:\n        fmt.Print(x.(Person))\n    case chan int:\n        fmt.Print(x.(chan int))\n    default:\n        fmt.Print(\"Unknown type\")\n    }\n\n    fmt.Print(\"\\n\")\n}\n</code></pre>\n<p>Another example from AOC 2021 Day 16. This sets the var <code>p</code> to the valid type as well.</p>\n<pre><code class=\"language-go\"> switch p := packet.(type) {\n case Literal:\n  decoded += int(p.Value)\n case Operator:\n  switch p.TypeId {\n  case 0:\n   // sum of subpackets\n   for _, p2 := range p.Packets {\n    decoded += DecodePacket(p2)\n   }\n  }\n</code></pre>\n<h2>Recursion</h2>\n<p><a href=\"https://golangdocs.com/recursion-in-golang\">https://golangdocs.com/recursion-in-golang</a></p>\n<p>Regular recusion:</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n)\n\nfunc fib(n int) int {\n    if (n == 0) {\n        return 0\n    } else if(n == 1) {\n        return 1\n    } else {\n        return fib(n-1) + fib(n-2)\n    }\n}\n\nfunc main() {\n    fmt.Println(fib(10))  // 55\n}\n</code></pre>\n<p>Tail recursion:</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n)\n\nfunc f(v int) {\n    if(v == 0) {\n        fmt.Println(\"Zero\")\n        return\n    } else {\n        fmt.Println(v)\n        f(v-1)               // tail-recursive call\n    }\n}\n\nfunc main() {\n    f(5)\n\n    // output:\n    // 5\n    // 4\n    // 3\n    // 2\n    // 1\n    // Zero\n}\n</code></pre>\n<h2>Error Handling</h2>\n<ul>\n<li>If returning error, use pointers for value. makes returning nil possible and easier to handle. If value you would have to construct and empty Foo.</li>\n</ul>\n<pre><code class=\"language-go\">func CreateFoo(fail bool) (*Foo, error) {\n if fail {\n  return nil, fmt.Errorf(\"this is an error with value \")\n }\n return &#x26;Foo{}, nil\n}\n\nfunc main() {\n foo, err := CreateFoo(false)\n}\n</code></pre>\n<h2>File Handling</h2>\n<ul>\n<li><a href=\"https://blog.carlmjohnson.net/post/2021/how-to-use-go-embed/\">embed</a></li>\n</ul>\n<h2>Values vs Pointer receiver</h2>\n<ul>\n<li>default to pointer unless you know you need a value</li>\n<li>value receivers receive a copy, pointers don't.</li>\n<li>value receivers may have perf wins</li>\n</ul>\n<pre><code class=\"language-go\">type Foo struct {\n    thing int\n}\n\n// value receiver\nfunc (f Foo) fA() {\n    ...\n    f.thing = 5; // DOESNT DO ANYTHING\n}\n\n// pointer receiver\nfunc (f *Foo) fB() {\n    ...\n    f.thing = 5; // CHANGES\n}\n</code></pre>\n<h2>Structs</h2>\n<pre><code class=\"language-go\">type GoLangStruct struct {\n    y int\n    x int\n}\n\nfunc NewStruct(x, y int) GoLangStruct {\n    return GoLangStruct{x, y} // x will equal y, it goes by order not name\n}\n\nfunc main() {\n    fmt.Printf(\"%+v\\n\", NewStruct(9, 6));\n}\n</code></pre>","frontmatter":{"date":"March 11, 2023","title":"Golang","tags":["language"]}}},"pageContext":{"slug":"/golang/"}},"staticQueryHashes":["1865044719","3489759178","3649515864"],"slicesMap":{}}