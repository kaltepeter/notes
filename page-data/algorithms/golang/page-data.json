{"componentChunkName":"component---src-templates-note-template-tsx","path":"/algorithms/golang/","result":{"data":{"markdownRemark":{"html":"<h2>Depth First</h2>\n<ul>\n<li>\n<p><a href=\"https://iq.opengenus.org/depth-first-search/\">https://iq.opengenus.org/depth-first-search/</a></p>\n</li>\n<li>\n<p><a href=\"https://codetree.dev/golang-graph-traversal/\">https://codetree.dev/golang-graph-traversal/</a></p>\n</li>\n</ul>\n<pre><code class=\"language-go\">func DFS(g *graph.Graph, startVertex *graph.Vertex, visitCb func(int)) {\n // we maintain a map of visited nodes to prevent visiting the same\n // node more than once\n visited := map[int]bool{}\n\n if startVertex == nil {\n  return\n }\n visited[startVertex.Key] = true\n visitCb(startVertex.Key)\n\n // for each of the adjacent vertices, call the function recursively\n // if it hasn't yet been visited\n for _, v := range startVertex.Vertices {\n  if visited[v.Key] {\n   continue\n  }\n  DFS(g, v, visitCb)\n }\n}\n</code></pre>\n<h2>Binary Search Tree</h2>\n<p><a href=\"https://hackthedeveloper.com/golang-binary-search-tree/\">https://hackthedeveloper.com/golang-binary-search-tree/</a></p>\n<h2>Stack</h2>\n<p><a href=\"https://codeburst.io/slice-based-stack-implementation-in-golang-8140603a1dc2\">https://codeburst.io/slice-based-stack-implementation-in-golang-8140603a1dc2</a> Simple implementation</p>\n<h2>Find all rotations of a point</h2>\n<pre><code class=\"language-go\">type IntAdjList struct {\n Pos     int\n AdjList [][]int\n}\n\ntype Coord struct {\n X int\n Y int\n Z int\n}\n\nfunc NewIntAdjList(coord int, other [][]int) (c IntAdjList) {\n    c.Pos = coord\n    c.AdjList = append(c.AdjList, other...)\n    return\n}\n\nfunc calcCombos(g *IntAdjList) (cList []Coord) {\n    coord := &#x26;Coord{\n    X: g.Pos,\n    }\n    p1 := g.AdjList[0]\n    p2 := g.AdjList[1]\n    coord.Y = p1[0]\n    coord.Z = p2[0]\n    cList = append(cList, *coord)\n    coord.Y = p1[1]\n    coord.Z = p2[1]\n    cList = append(cList, *coord)\n    coord.Y = p1[0]\n    coord.Z = p2[1]\n    cList = append(cList, *coord)\n    coord.Y = p1[1]\n    coord.Z = p2[0]\n    cList = append(cList, *coord)\n    return\n}\n\n## All rotations of a coord\n\nfunc (c *Coord) GetAllRotations() map[Coord]bool {\n    coords := map[Coord]bool{}\n    pairs := [][]int{{c.X, c.X * -1}, {c.Y, c.Y * -1}, {c.Z, c.Z * -1}}\n    for i, c := range pairs {\n        pList := [][]int{}\n        \n        if i > 0 {\n            pList = append(pList, pairs[:i]...)\n        }\n\n        if i &#x3C; len(pairs)-1 {\n            pList = append(pList, pairs[i+1:]...)\n        }\n\n        cListL := NewIntAdjList(c[0], pList)\n        cListR := NewIntAdjList(c[1], pList)\n        adjList := calcCombos(&#x26;cListL)\n        adjList = append(adjList, calcCombos(&#x26;cListR)...)\n        \n        for _, c := range adjList {\n            coords[c] = true\n        }\n    }\n\n    return coords\n}\n</code></pre>\n<p><a href=\"https://play.golang.com/p/7GT97c-qX6H\">Playground Link</a></p>\n<h2>Linear Algebra, Machine learning</h2>\n<h3>gonum</h3>\n<p><a href=\"https://medium.com/wireless-registry-engineering/gonum-tutorial-linear-algebra-in-go-21ef136fc2d7\">https://medium.com/wireless-registry-engineering/gonum-tutorial-linear-algebra-in-go-21ef136fc2d7</a> - good basic walkthrough</p>\n<p><a href=\"https://pkg.go.dev/gonum.org/v1/gonum@v0.9.3\">https://pkg.go.dev/gonum.org/v1/gonum@v0.9.3</a> - Documentation</p>\n<h3>Matrix</h3>\n<p>Get teh neighbors of a point</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n \"fmt\"\n \"gonum.org/v1/gonum/mat\"\n)\n\nfunc matPrint(X mat.Matrix) {\n fa := mat.Formatted(X, mat.Prefix(\"\"), mat.Squeeze())\n fmt.Printf(\"%v\\n\\n\", fa)\n}\n\nfunc main() {\n m := mat.NewDense(4, 4, []float64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15})\n rows, cols := m.Dims()\n matPrint(m)\n\n startI := 0\n startJ := 0\n endI := rows\n endJ := cols\n for i := 0; i &#x3C; rows; i++ {\n  for j := 0; j &#x3C; cols; j++ {\n   fmt.Println(\"for num: \", m.At(i, j), \" \", i, \",\", j)\n   if i > 0 {\n    startI = i - 1\n   } else if i == 0 {\n    startI = i\n   }\n   if i &#x3C; rows-1 {\n    endI = i + 2\n   }\n   if j > 0 {\n    startJ = j - 1\n   } else if j == 0 {\n    startJ = j\n   }\n   if j &#x3C; cols-1 {\n    endJ = j + 2\n   }\n   s := m.Slice(startI, endI, startJ, endJ)\n   matPrint(s)\n  }\n }\n}\n</code></pre>\n<p><a href=\"https://play.golang.com/p/adPKV0EBdD4\">Playground Link</a></p>\n<h2>Sorting</h2>\n<p><a href=\"https://medium.com/@kdnotes/how-to-sort-golang-maps-by-value-and-key-eedc1199d944\">https://medium.com/@kdnotes/how-to-sort-golang-maps-by-value-and-key-eedc1199d944</a></p>\n<h2>Enums</h2>\n<p><a href=\"https://blog.learngoprogramming.com/golang-const-type-enums-iota-bc4befd096d3\">https://blog.learngoprogramming.com/golang-const-type-enums-iota-bc4befd096d3</a></p>\n<pre><code class=\"language-go\">type Weekday int\n\nconst (\n    Sunday    Weekday = iota + 1 // value: 1, type: Weekday\n    Monday                       // value: 2, type: Weekday\n    Tuesday                      // value: 3, type: Weekday\n    Wednesday                    // value: 4, type: Weekday\n    Thursday                     // value: 5, type: Weekday\n    Friday                       // value: 6, type: Weekday\n    Saturday                     // value: 7, type: Weekday\n)\n</code></pre>\n<p><a href=\"https://go.dev/play/p/NEpyw07ts9\">Playground Link</a></p>","frontmatter":{"date":"December 01, 2021","title":"Golang","tags":null}}},"pageContext":{"slug":"/algorithms/golang/"}},"staticQueryHashes":["1865044719","3489759178","3649515864"],"slicesMap":{}}