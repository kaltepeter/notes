{
    "componentChunkName": "component---src-templates-note-template-tsx",
    "path": "/algorithms/golang/",
    "result": {"data":{"markdownRemark":{"html":"<h2>Depth First</h2>\n<ul>\n<li>\n<p><a href=\"https://iq.opengenus.org/depth-first-search/\">https://iq.opengenus.org/depth-first-search/</a></p>\n</li>\n<li>\n<p><a href=\"https://codetree.dev/golang-graph-traversal/\">https://codetree.dev/golang-graph-traversal/</a></p>\n</li>\n</ul>\n<pre><code class=\"language-go\">func DFS(g *graph.Graph, startVertex *graph.Vertex, visitCb func(int)) {\n // we maintain a map of visited nodes to prevent visiting the same\n // node more than once\n visited := map[int]bool{}\n\n if startVertex == nil {\n  return\n }\n visited[startVertex.Key] = true\n visitCb(startVertex.Key)\n\n // for each of the adjacent vertices, call the function recursively\n // if it hasn't yet been visited\n for _, v := range startVertex.Vertices {\n  if visited[v.Key] {\n   continue\n  }\n  DFS(g, v, visitCb)\n }\n}\n</code></pre>\n<h2>Binary Search Tree</h2>\n<p><a href=\"https://hackthedeveloper.com/golang-binary-search-tree/\">https://hackthedeveloper.com/golang-binary-search-tree/</a></p>\n<h2>Stack</h2>\n<p><a href=\"https://codeburst.io/slice-based-stack-implementation-in-golang-8140603a1dc2\">https://codeburst.io/slice-based-stack-implementation-in-golang-8140603a1dc2</a> Simple implementation</p>\n<h2>Find all rotations of a point</h2>\n<pre><code class=\"language-go\">type IntAdjList struct {\n Pos     int\n AdjList [][]int\n}\n\ntype Coord struct {\n X int\n Y int\n Z int\n}\n\nfunc NewIntAdjList(coord int, other [][]int) (c IntAdjList) {\n    c.Pos = coord\n    c.AdjList = append(c.AdjList, other...)\n    return\n}\n\nfunc calcCombos(g *IntAdjList) (cList []Coord) {\n    coord := &#x26;Coord{\n    X: g.Pos,\n    }\n    p1 := g.AdjList[0]\n    p2 := g.AdjList[1]\n    coord.Y = p1[0]\n    coord.Z = p2[0]\n    cList = append(cList, *coord)\n    coord.Y = p1[1]\n    coord.Z = p2[1]\n    cList = append(cList, *coord)\n    coord.Y = p1[0]\n    coord.Z = p2[1]\n    cList = append(cList, *coord)\n    coord.Y = p1[1]\n    coord.Z = p2[0]\n    cList = append(cList, *coord)\n    return\n}\n\n## All rotations of a coord\n\nfunc (c *Coord) GetAllRotations() map[Coord]bool {\n    coords := map[Coord]bool{}\n    pairs := [][]int{{c.X, c.X * -1}, {c.Y, c.Y * -1}, {c.Z, c.Z * -1}}\n    for i, c := range pairs {\n        pList := [][]int{}\n\n        if i > 0 {\n            pList = append(pList, pairs[:i]...)\n        }\n\n        if i &#x3C; len(pairs)-1 {\n            pList = append(pList, pairs[i+1:]...)\n        }\n\n        cListL := NewIntAdjList(c[0], pList)\n        cListR := NewIntAdjList(c[1], pList)\n        adjList := calcCombos(&#x26;cListL)\n        adjList = append(adjList, calcCombos(&#x26;cListR)...)\n\n        for _, c := range adjList {\n            coords[c] = true\n        }\n    }\n\n    return coords\n}\n</code></pre>\n<p><a href=\"https://play.golang.com/p/7GT97c-qX6H\">Playground Link</a></p>\n<h2>Linear Algebra, Machine learning</h2>\n<h3>gonum</h3>\n<p><a href=\"https://medium.com/wireless-registry-engineering/gonum-tutorial-linear-algebra-in-go-21ef136fc2d7\">https://medium.com/wireless-registry-engineering/gonum-tutorial-linear-algebra-in-go-21ef136fc2d7</a> - good basic walkthrough</p>\n<p><a href=\"https://pkg.go.dev/gonum.org/v1/gonum@v0.9.3\">https://pkg.go.dev/gonum.org/v1/gonum@v0.9.3</a> - Documentation</p>\n<h2>Sorting</h2>\n<p><a href=\"https://medium.com/@kdnotes/how-to-sort-golang-maps-by-value-and-key-eedc1199d944\">https://medium.com/@kdnotes/how-to-sort-golang-maps-by-value-and-key-eedc1199d944</a></p>","frontmatter":{"date":"December 01, 2021","title":"Golang","tags":null}}},"pageContext":{"slug":"/algorithms/golang/"}},
    "staticQueryHashes": ["1929983096","3649515864"]}