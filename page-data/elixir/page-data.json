{
    "componentChunkName": "component---src-templates-note-template-tsx",
    "path": "/elixir/",
    "result": {"data":{"markdownRemark":{"html":"<h2>Install/Tools</h2>\n<p><code>brew install elixir</code></p>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=JakeBecker.elixir-ls\">VSCode Extension</a></p>\n<h2>Docs</h2>\n<p><a href=\"https://elixir-lang.org/getting-started/introduction.html\">Guides</a>\n<a href=\"https://hexdocs.pm/elixir/Kernel.html\">Standard Library Docs</a></p>\n<h2>Books</h2>\n<p><a href=\"https://pragprog.com/titles/cdc-elixir/learn-functional-programming-with-elixir/\">Learn Functional Programming with Elixir</a></p>\n<h2>Repl</h2>\n<p><code>iex</code> start interactive session\n<code>c('filename')</code> load a file into session</p>\n<h2>Dependencies</h2>\n<ul>\n<li><a href=\"https://hex.pm/\">Hex Package Manager</a></li>\n</ul>\n<ol>\n<li>edit <code>mix.exs</code></li>\n</ol>\n<pre><code class=\"language-elixir\">defp deps do\n  [{dialyxir, \"~> 0.5\", only: [:dev], runtime: false}]\nend\n</code></pre>\n<ol start=\"2\">\n<li><code>mix do deps.get, deps.compile</code></li>\n<li><code>mix dialyzer</code></li>\n</ol>\n<h2>About Elixir</h2>\n<ul>\n<li>Elixir runs on the BEAM VM (erlang)</li>\n<li>Erlang is compatible. Syntax is familiar to Ruby</li>\n<li>Concurrency up front</li>\n<li>Functional</li>\n<li>Speed</li>\n</ul>\n<h2>Functional Programming with Elxir</h2>\n<ul>\n<li>immutable data</li>\n<li>functions</li>\n<li>declarative code</li>\n</ul>\n<h3>Pure Functions</h3>\n<ul>\n<li>values are immutable</li>\n<li>fn result is only affected by the args</li>\n<li>fn doesn't generate effects beyond the value it returns</li>\n<li>predictable</li>\n<li>can return errors</li>\n<li>referential transparency: total.(100,8) == 8.0</li>\n</ul>\n<h3>Impure Functions</h3>\n<ul>\n<li>may not return consistent results when given the same inputs</li>\n<li>may produce effects beyond the function's scope</li>\n<li>unpredictable</li>\n<li>fn are impure when they reference values outside of a function scope</li>\n<li>produces side effects</li>\n</ul>\n<h3>Working with pure/impure functions</h3>\n<ul>\n<li>isolate pure from impure</li>\n<li>write more pure</li>\n<li>handle impure functions</li>\n</ul>\n<h3>Using values explicitly</h3>\n<ul>\n<li>always pass values between fns</li>\n<li>clear inputs/outputs</li>\n</ul>\n<h3>Transforming values</h3>\n<ul>\n<li><code>|></code> pipe operator</li>\n<li>result is passed into the next function</li>\n</ul>\n<h3>Declarative code</h3>\n<ul>\n<li>focuses on what is necessary to solve a problem</li>\n</ul>\n<h2>Values</h2>\n<p><code>atom</code> is a const, like a symbol. e.g. <code>:true</code>, <code>:false</code>, <code>:nil</code>\n<code>&#x3C;></code> is a string concat operator\n<code>and</code>, <code>or</code>, <code>not</code> are meant for boolean comparisons\n<code>&#x26;&#x26;</code>, <code>||</code>, <code>!</code> compare truthy and falsy values</p>\n<h3>Naming</h3>\n<ul>\n<li>vars are snake_case</li>\n<li>aliases start with a capital letter</li>\n<li>modules are Pascal case</li>\n</ul>\n<h3>Functions</h3>\n<ul>\n<li>the last statement is the return value</li>\n<li>max of 255 parameters, best practice is less than 5</li>\n<li>first class citizens</li>\n<li>named functions are defined in modules</li>\n<li><code>()</code> are optional</li>\n</ul>\n<p>common functional pattern:</p>\n<pre><code class=\"language-elixir\">upcase = fn string -> String.upcase(string) end\nupcase.(\"hello, world\")\n</code></pre>\n<p>using capturing operator</p>\n<pre><code class=\"language-elixir\">upcase = &#x26;String.upcase\nupcase.(\"hello, world\")\n</code></pre>\n<h3>Modules</h3>\n<ul>\n<li>importing arity <code>import File, only: [write: 3, read: 2]</code></li>\n<li>explicit arity imports are preferred</li>\n</ul>\n<h3>Strings</h3>\n<p><code>#{my_var}</code> string interpolation</p>\n<h2>Matching</h2>\n<ul>\n<li>Pattern matching in functional programming can control flow.</li>\n<li>Useful for assigning variables, unpacking values and making decisions.</li>\n<li>Operator raises a MatchError when it fails to match</li>\n</ul>\n<p>When the variable is on the left:</p>\n<ul>\n<li>it's assignment</li>\n<li>will match everything, binding the value to the right side</li>\n<li>Binding to existing variables is called 'rebinding'</li>\n<li>To avoid rebinding use the pin operator <code>^</code></li>\n</ul>\n<p><code>1 = 1</code> # 1\n<code>2 = 1</code> # MatchError</p>\n<pre><code class=\"language-elixir\">x = 1 # 1\n1 = x # 1\n2 = x # MatchError\nx = 2 # rebind\n^x = 2 # 2\n^x = 1 # match error\n</code></pre>\n<p>Destructuring</p>\n<ul>\n<li>Matching parts of a string, use the <code>&#x3C;></code> operator the check a string</li>\n<li>Can't use a variable on the left side of the <code>&#x3C;></code> operator</li>\n</ul>\n<pre><code class=\"language-elixir\">\"Authentication: \" &#x3C;> credentials = \"Authentication: Basic dXNlcjpwYXNz\"\ncredentials # \"Basic dXNlcjpwYXNz\"\n</code></pre>\n<h3>Tuples</h3>\n<ul>\n<li>Functions might not be consistent when returning tuples, some may return an atom for the unsuccessful result and a tuple for the successful one.</li>\n<li>A good practice, a common one, is to return <code>{:ok, value}</code> for success and <code>{:error, :error_type}</code> for failure.</li>\n<li>Tuples must have a known length and use contiguous memory.</li>\n</ul>\n<pre><code class=\"language-elixir\">{a,b,c} = {4,5,6}\na # 4\n</code></pre>\n<p>Signaling success and failures</p>\n<pre><code class=\"language-elixir\">process_life = fn -> {:ok, 42} end\n{:ok, answer} = process_life.()\nIO.puts \"The answer is #{answer}.\" # The answer is 42\n</code></pre>\n<p>Equals operators</p>\n<ul>\n<li><code>=</code> is used for pattern matching</li>\n<li><code>==</code> is used when the values are equal</li>\n<li><code>===</code> is used to check value and type</li>\n</ul>\n<pre><code class=\"language-elixir\">1 = 1 # 1\n2 = 1 # match error!\n1 == 1.0 # true\n2 == 1 # false\n1.0 === 1.0 # true\n1.0 === 1 # false\n</code></pre>\n<p>Example</p>\n<pre><code class=\"language-elixir\">user_input = IO.gets(\"Write your ability scrore:\\n\")\n{ability_score, _} = Integer.parse(user_input)\nability_modifier = (ability_score - 10) / 2\nIO.puts(\"Your ability modifier is #{ability_modifier}\")\n</code></pre>\n<p><code>{ability_score, _} = Integer.parse(user_input)</code> isn't using a success atom, the tuple is enough. If the parsing is successful, the expression also binds the first element to the variable <code>ability_score</code> and ignores the remaining text using the wildcard <code>_</code>.</p>\n<h3>Matching lists</h3>\n<ul>\n<li>For unknown length use a list. The lists are linked lists, each item contains a reference to the next item.</li>\n<li>A lists ends by linking to an empty list, turning it into a proper list.</li>\n<li>It's useful to avoid infinite loops by checking if the last item is an empty list and stopping recursion.</li>\n<li>Use <code>_</code> wildcard to ignore items</li>\n<li><code>|</code> splits the elements you care about from the rest.</li>\n</ul>\n<pre><code class=\"language-elixir\">[a,a,a] = [1,1,1] # the list must have three elements with the same value\n[a,b,a] = [1,2,1] # [1,2,1]\n[a,a,a] = [\"apples\", \"apples\", \"apples\"]\n[a, a, \"pineapples\"] = [\"apples\", \"apples\", \"pineapples\"] \n[head | tail] = [:a, :b, :c, :d]\nhead # :a\ntail # [:b, :c, :d]\n[head | tail] = [:a]\ntail # []\n[head | tail] = [] # match error\n[a,b | rest] = [1,2,3,4]\na # 1\nb # 2\nrest # [3,4]\n</code></pre>\n<h3>Matching Maps</h3>\n<ul>\n<li>Maps are key/value pairs</li>\n<li><code>%{}</code> is used to create map values</li>\n<li><code>=></code> is an alternative syntax, more verbose but can store an value as a key</li>\n<li><code>%{strength: strength_value} = abilities</code> pattern match object value</li>\n<li><code>%{}</code> will match all maps</li>\n</ul>\n<pre><code class=\"language-elixir\">user_signup = %{email: \"johndoe@mail.com\", password: \"12345678\"}\nuser_signup = %{:email => \"johndoe@mail.com\", :password => \"12345678\"} # equivalent\n\nabilities = %{strength: 16, dexterity: 12, intelligence: 10}\n%{strength: strength_value} = abilities\nstrength_value # 16\n\n# matching and setting at the same time\n%{intelligence: 10, dexterity: dexterity_value} = abilities\ndexterity_value # 12\n\n# check and bind at the same time, one step use for simple assignments\n# basic filter\n%{strength: strength_value = 16} = abilities\nstrength_value # 16\n\n# two step version, use when you have some calculation or function call on the variables\nstrength_value = 16\n%{strength: ^strength_value} = abilities\n</code></pre>\n<h3>Maps vs Keyword Lists</h3>\n<ul>\n<li>A keyword list is a list of two-element tuples, it allows duplicate keys but they must be atoms</li>\n<li>keywords are useful for function options, e.g. the import directive takes a keyword list because named functions can have identical names with different arity</li>\n<li>keyword lists permit you to create structures with identical keys but different values</li>\n<li>maps are useful for things representing database rows, because column names are unique</li>\n<li>the syntax of maps and keywords is very similar, but their limitations make them handy for different use cases</li>\n</ul>\n<pre><code class=\"language-elixir\">[b,c] = [a: 1, a: 12]\nb # {:a, 1}\nc # {:a, 12}\n\nimport String, only: [pad_leading: 2, pad_leading: 3]\npad_leading(\"def\", 6) # \"   def\"\npad_leading(\"def\", 6, \"-\") # \"---def\"\n\nx = %{a: 1, a: 12} # {a:12}\nx = [a: 1, a: 12] # OK\nx = [{:a, 1}, {:a, 12}] # same as above\nx = %{1 => :a, 2 => :b} # ok\nx = [1 => :a, 2 => :b] # syntax error\n</code></pre>\n<h3>Matching Structs</h3>\n<ul>\n<li>structs are extensions of mapping structures</li>\n<li>useful for representing consistent structures that have the same set of keys everywhere</li>\n<li>All structs have a list of permitted attributes</li>\n<li>Not possible to use a key that's not in the list of allowed attributes</li>\n<li>Only functional difference between structs and maps, the name of the struct can be used to indicate which type of structure we're expecting</li>\n</ul>\n<pre><code class=\"language-elixir\">date = ~D[2018-01-01]\n%{year: year} = date\nyear # 22018\n</code></pre>\n<p><code>~D</code> is a sigil, sigils are shortcuts to create values\n<code>~w(chocolate jelly mint)</code> # [\"chocolate\", \"jelly\", \"mint\"], sigil for each word as string</p>\n<pre><code class=\"language-elixir\">date = ~D[2018-01-01]\n%Date{day: day} = date\nday # 1\n%Date{day: day} = %{day: 1} # Match error\n</code></pre>\n<h2>Matching functions</h2>\n<ul>\n<li>function clauses must be collocated, nothing in between</li>\n<li></li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule NumberCompare do\n  def greater(number, other_number) do\n    check(number >= other_number, number, other_number)\n  end\n\n  defp check(true, number, _), do: number # matches if first arg true\n  defp check(false, _, other_number), do: other_number # matches if first arg is false\nend\n</code></pre>\n<ul>\n<li>multiple functions with different values (function clauses)</li>\n<li>select based on first arg match</li>\n<li>returns the number that is greater or equal</li>\n<li>Only <code>greater/2</code> is public, <code>check/3</code> is internal, using <code>defp</code> directive</li>\n</ul>\n<h3>Default function values</h3>\n<ul>\n<li>only one default value for each parameter</li>\n<li>functions have fixed arity</li>\n<li>functions with same name but different number of parameters are different functions</li>\n</ul>\n<p><code>\\\\</code> operator</p>\n<pre><code class=\"language-elixir\">defmodule Checkout do\n  def total_cost(price, quantity \\\\ 10), do: price * quantity\nend\nCheckout.total_cost(12) # 120, uses default value\nCheckout.total_cost(12, 5) # 60, uses second arg\n</code></pre>\n<h2>Guard Clauses</h2>\n<ul>\n<li>using <code>when</code> keyword after functions parameters</li>\n<li>Help us create better function signatures, reducing the need for function helpers</li>\n<li>Enforce which data we are expecting</li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule NumberCompareV2 do\n  def greater(number, other_number) when number >= other_number, do: number\n  def greater(_, other_number), do: other_number\nend\nNumberCompareV2.greater(2,8) # 8\n</code></pre>\n<p>Uses a guard clause to return the number if greater, else the other</p>\n<pre><code class=\"language-elixir\">defmodule CheckoutV2 do\n  def total_cost(price, tax_rate) when price >= 0 and tax_rate >= 0 do\n    price * (tax_rate + 1)\n  end\nend\n\nCheckoutV2.total_cost(40, 0.1) # 44.0\nCheckoutV2.total_cost(-2, 0.2) # FunctionClauseError\nCheckoutV2.total_cost(42.3, \"Hellow, World!\") # ArithmeticError\n</code></pre>\n<ul>\n<li>The last example passes the guard check because you can compare string to number and it's greater than 0.</li>\n<li>This makes it practical to sort mixed lists.</li>\n</ul>\n<p>Anonymous function arguments</p>\n<pre><code class=\"language-elixir\">number_compare = fn\n  number, other_number when number >= other_number -> number\n  _, other_number -> other_number\nend\nnumber_compare_v3.(1,2) # 2    \n</code></pre>\n<ul>\n<li><a href=\"https://elixir-lang.org/getting-started/case-cond-and-if.html#expressions-in-guard-clauses\">Functions/Operators allowed in guard clause</a></li>\n<li>Can't use standard functions because the checker needs to be fast and have no side effects</li>\n<li>Erlang and Elixir ensure purity and speed by creating a list of authorized functions and that can be expanded using macro functions.</li>\n</ul>\n<h3>Macros</h3>\n<ul>\n<li><a href=\"https://hexdocs.pm/elixir/Integer.html#macros\">Macros</a></li>\n<li><a href=\"https://elixir-lang.org/getting-started/meta/macros.html\">Meta Programming with Macros</a></li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule EvenOrOdd do\n  require Integer\n\n  def check(number) when Integer.is_even(number), do: \"even\"\n  def check(number) when Integer.is_odd(number), do: \"odd\"\nend\n\nEvenOrOdd.check(42) # \"even\" \nEvenOrOdd.check(43) # \"odd\"\n</code></pre>\n<ul>\n<li><code>require</code> is needed to import macro functions</li>\n<li>code is generated before evaluating</li>\n<li>require is lexically scoped</li>\n<li>create macro with <code>defguard</code> directive</li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule CheckoutV2 do\n  defguard is_rate(value) when is_float(value) and value >= 0 and value &#x3C;= 1\n  defguard is_cents(value) when is_integer(value) and value >= 0\n\n  def total_cost(price, tax_rate) when is_cents(price) and is_rate(tax_rate) do\n    price + tax_cost(price, tax_rate)\n  end\n\n  def tax_cost(price, tax_rate) when is_cents(price) and is_rate(tax_rate) do\n    price * tax_rate\n  end\nend\nCheckoutV2.tax_cost(40, 0.1) # 4.0\nCheckoutV2.tax_cost(-2, 0.2) # FunctionClauseError\nCheckoutV2.tax_cost(42.3, \"Hello, World!\") # FunctionClauseError\n</code></pre>\n<ul>\n<li>creates a custom macro with defguard</li>\n</ul>\n<h2>Type specs/declaration</h2>\n<ul>\n<li>dynamically types</li>\n<li>Don't have to be defensive about types</li>\n<li>The compiler never uses type specifications to optimize or modify the code.</li>\n<li>Use automated tests and pattern matching to ensure things are working</li>\n<li>Type specifications are useful for creating documentation and have static analysis to find inconsistencies and possible bugs</li>\n<li><a href=\"https://hexdocs.pm/elixir/typespecs.html\">Type Specs</a></li>\n<li>Dialyzer tool uses types specs to static check</li>\n<li><a href=\"https://github.com/jeremyjh/dialyxir\">Dialyzer</a></li>\n</ul>\n<pre><code class=\"language-elixir\">dialyzer: [plt_add_apps: [:mix]]\n</code></pre>\n<pre><code class=\"language-elixir\">  @type t :: %DungeonCrawl.Character{\n          name: String.t(),\n          description: String.t(),\n          hit_points: non_neg_integer(),\n          max_hit_points: non_neg_integer(),\n          attack_description: String.t(),\n          damage_range: Range.t()\n        }\n</code></pre>\n<h2>Bitwise</h2>\n<ul>\n<li><a href=\"https://hexdocs.pm/elixir/Bitwise.html\">Bitwise</a></li>\n</ul>\n<p><code>&#x26;&#x26;&#x26;</code> bitwise and</p>\n<h2>Recursion</h2>\n<ul>\n<li>bounded recursion is a recursive function with an end</li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule Sum do\n  def up_to(0), do: 0\n  def up_to(n), do: n + up_to(n - 1)\nend\n\nSum.up_to(10) # 55\n</code></pre>\n<ul>\n<li>The first clause matches if the arg is 0. else the second clause recurses.</li>\n<li>The bounded clause must be first to protect from infinite repetition</li>\n</ul>\n<p>recurse a list</p>\n<pre><code class=\"language-elixir\">defmodule Math do\n  def sum([]), do: 0\n  def sum([head | tail]), do: head + sum(tail)\nend\nMath.sum([10,5,15]) # 30\nMath.sum([]) # 0\n</code></pre>\n<h3>Transforming Lists</h3>\n<pre><code class=\"language-elixir\">[:a | [:b, :c]] # [:a, :b, :c]\n[:a, :b | [:c]] # [:a, :b, :c]\n[:a, :b, :c] # [:a, :b, :c]\n</code></pre>\n<ul>\n<li>These will build a new list, one element at a time</li>\n<li>This syntax is prepending an element to a list, which is much faster than <code>++</code></li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule EnchanterShop do\n  def test_data do\n    [\n      %{title: \"Longsword\", price: 50, magic: false},\n      %{title: \"Healing Potion\", price: 60, magic: true},\n      %{title: \"Rope\", price: 10, magic: false},\n      %{title: \"Dragon's Spear\", price: 100, magic: true}\n    ]\n  end\n\n  @enchanter_name \"Edwin\"\n\n  def enchant_for_sale([]), do: []\n\n  def enchant_for_sale([item = %{magic: true} | incoming_items]) do\n    [item | enchant_for_sale(incoming_items)]\n  end\n\n  def enchant_for_sale([item | incoming_items]) do\n    new_item = %{title: \"#{@enchanter_name}'s #{item.title}\", price: item.price * 3, magic: true}\n    [new_item | enchant_for_sale(incoming_items)]\n  end\nend\n\nEnchanterShop.enchant_for_sale(EnchanterShop.test_data)\n</code></pre>\n<p>output</p>\n<pre><code class=\"language-bash\">[\n  %{magic: true, price: 150, title: \"Edwin's Longsword\"},\n  %{magic: true, price: 60, title: \"Healing Potion\"},\n  %{magic: true, price: 30, title: \"Edwin's Rope\"},\n  %{magic: true, price: 100, title: \"Dragon's Spear\"}\n]\n</code></pre>\n<h3>Key-based Accessors</h3>\n<ul>\n<li>keywords and maps have a syntax to access values using [], if the key is missing nil is returned and no error</li>\n<li>structs and maps can access with dot notation, if the key is missing an error is raised</li>\n</ul>\n<pre><code class=\"language-elixir\">item = %{magic: true, price: 150, title: \"Edwin's Longsword\"}\nitem[:title] # \"Edwin's Longsword\"\nitem[:owner] # nil\nitem[:creator][:city] # nil\n\nitem.title # \"Edwin's Longsword\"\nitem.owner # raises a KeyError\n</code></pre>\n<h2>Recursion techniques</h2>\n<p>1.Decrease and conquer</p>\n<pre><code class=\"language-elixir\">defmodule Factorial do\n    def of(0), do: 1\n    def of(n) when n > 0, do: n * of(n - 1)\nend\nFactorial.of(5) # 120\n</code></pre>\n<p>2.Divide and conquer</p>\n<pre><code class=\"language-elixir\">defmodule Sort do\n  def ascending([]), do: []\n  def ascending([a]), do: [a]\n\n  def ascending(list) do\n    half_size = div(Enum.count(list), 2)\n    {list_a, list_b} = Enum.split(list, half_size)\n    merge(ascending(list_a), ascending(list_b))\n  end\n\n  defp merge([], list_b), do: list_b\n  defp merge(list_a, []), do: list_a\n\n  defp merge([head_a | tail_a], list_b = [head_b | tail_b]) when head_a &#x3C;= head_b do\n    [head_a | merge(tail_a, list_b)]\n  end\n\n  defp merge(list_a = [head_a | _], [head_b | tail_b]) when head_a > head_b do\n    [head_b | merge(list_a, tail_b)]\n  end\nend\nSort.ascending([9,5,1,5,4]) # [1, 4, 5, 5, 9]\nSort.ascending([2,2,3,1])  # [1, 2, 2, 3]\n</code></pre>\n<h2>Tail-Call Optimization</h2>\n<ul>\n<li>the compiler reduces functions in memory without allocating more memory</li>\n<li>to use, ensure the last expression of the function is a call to a function</li>\n<li>if the last expression is a function call, then the current functions return is he return of the new function call and it doesn't need to keep the current in memory</li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule TrFactorial do\n  def of(n), do: factorial_of(n, 1)\n  defp factorial_of(0, acc), do: acc\n  defp factorial_of(n, acc) when n > 0, do: factorial_of(n - 1, n * acc)\nend\nTrFactorial.of(10000) # returns much faster than the original body recursive \n</code></pre>\n<h2>unbounded recursion</h2>\n<ul>\n<li>can't predict the number of repetitions</li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule Navigator do\n  def navigate(dir) do\n    expanded_dir = Path.expand(dir)\n    go_through([expanded_dir])\n  end\n\n  defp go_through([]), do: nil\n\n  defp go_through([content | rest]) do\n    print_and_navigate(content, File.dir?(content))\n    go_through(rest)\n  end\n\n  defp print_and_navigate(_dir, false), do: nil\n\n  defp print_and_navigate(dir, true) do\n    IO.puts(dir)\n    children_dirs = File.ls!(dir)\n    go_through(expand_dirs(children_dirs, dir))\n  end\n\n  defp expand_dirs([], _relative_to), do: []\n\n  defp expand_dirs([dir | dirs], relative_to) do\n    expanded_dir = Path.expand(dir, relative_to)\n    [expanded_dir | expand_dirs(dirs, relative_to)]\n  end\nend\nNavigator.navigate(\"..\") # prints dir\n</code></pre>\n<p>adding bounds</p>\n<pre><code class=\"language-elixir\">defmodule DepthNavigator do\n  @max_depth 2\n  def navigate(dir) do\n    expanded_dir = Path.expand(dir)\n    go_through([expanded_dir], 0)\n  end\n\n  defp go_through([], _current_depth), do: nil\n\n  defp go_through(_dirs, current_depth) when current_depth >= @max_depth, do: nil\n\n  defp go_through([content | rest], current_depth) do\n    print_and_navigate(content, File.dir?(content), current_depth)\n    go_through(rest, current_depth)\n  end\n\n  defp print_and_navigate(_dir, false, _current_depth), do: nil\n\n  defp print_and_navigate(dir, true, current_depth) do\n    IO.puts(dir)\n    children_dirs = File.ls!(dir)\n    go_through(expand_dirs(children_dirs, dir), current_depth + 1)\n  end\n\n  defp expand_dirs([], _relative_to), do: []\n\n  defp expand_dirs([dir | dirs], relative_to) do\n    expanded_dir = Path.expand(dir, relative_to)\n    [expanded_dir | expand_dirs(dirs, relative_to)]\n  end\nend\nDepthNavigator.navigate(\"..\") # bounded by depth\n</code></pre>\n<h3>recurse anonymous functions</h3>\n<pre><code class=\"language-elixir\">fact_gen = fn me ->\n  fn\n    0 -> 1\n    x when x > 0 -> x * me.(me).(x - 1)\n  end\nend\n\nfactorial = fact_gen.(fact_gen)\nfactorial.(5)\n</code></pre>\n<ul>\n<li><code>me</code> argument represents the factorial generator, representing itself</li>\n<li><code>me.(me)</code> produces a factorial function</li>\n<li>not very expressive code, not straight forward but possible</li>\n</ul>\n<pre><code class=\"language-elixir\">c(\"factorial.ex\")\nfactorial = &#x26;Factorial.of/1\nfactorial.(5)\n</code></pre>\n<ul>\n<li>use the capturing operator to reference a function</li>\n<li>using named functions as values</li>\n<li>easier to read than recursive anonymous function</li>\n</ul>\n<h2>Higher Order Functions</h2>\n<ul>\n<li>pass a function  into a function</li>\n<li>hides complexity</li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule MyListV2 do\n  def enchanted_items do\n    [\n      %{title: \"Edwin's Longsword\", price: 150},\n      %{title: \"Healing Potion\", price: 60},\n      %{title: \"Edwin's Rope\", price: 30},\n      %{title: \"Dragon's Spear\", price: 100}\n    ]\n  end\n\n  def each([], _function), do: nil\n\n  def each([head | tail], function) do\n    function.(head)\n    each(tail, function)\n  end\nend\nMyListV2.each(MyListV2.enchanted_items, fn item -> IO.puts item.title end)\n</code></pre>\n<pre><code class=\"language-elixir\">increase_price = fn i -> %{title: i.title, price: i.price * 1.1} end \nincrease_price = fn item -> update_in(item.price, &#x26;(&#x26;1 * 1.1)) end # same as above using built-in higher-order function\n</code></pre>\n<pre><code class=\"language-elixir\">  def reduce([], acc, _function), do: acc\n\n  def reduce([head | tail], acc, function) do\n    reduce(tail, function.(head, acc), function)\n  end\n  sum_price = fn item, sum -> item.price + sum end\n  MyListV2.reduce(MyListV2.enchanted_items, 0, sum_price) # 340\n\n    def filter([], _function), do: []\n\n  def filter([head | tail], function) do\n    if function.(head) do\n      [head | filter(tail, function)]\n    else\n      filter(tail, function)\n    end\n  end\n\n  MyListV2.filter(MyListV2.enchanted_items, fn item -> item.price &#x3C; 70 end)\n\n  MyListV2.filter([\"a\", \"b\", \"c\", \"d\"], &#x26;(&#x26;1 > \"b\")) # [\"c\", \"d\"]\n</code></pre>\n<h3>Using the enum module</h3>\n<ul>\n<li>The Enum module contains each, map, reduce and filter list operations.</li>\n<li>Work with any data type that respects <a href=\"https://hexdocs.pm/elixir/Enumerable.html\">Enumerable Protocol</a></li>\n</ul>\n<pre><code class=\"language-elixir\">Enum.each([\"dogs\", \"cats\", \"flowers\"], &#x26;(IO.puts String.upcase(&#x26;1)))\nEnum.map([\"dogs\", \"cats\", \"flowers\"], &#x26;String.capitalize/1)\nEnum.reduce([10,5,5,10], 0, &#x26;+/2)\nEnum.filter([\"a\", \"b\", \"c\", \"d\"], &#x26;(&#x26;1 > \"b\"))\n\nmedals = [\n  %{medal: :gold, player: \"Anna\"},\n  %{medal: :silver, player: \"Joe\"},\n  %{medal: :gold, player: \"Zoe\"},\n  %{medal: :bronze, player: \"Anna\"},\n  %{medal: :silver, player: \"Anderson\"},\n  %{medal: :silver, player: \"Peter\"}\n]\n\nEnum.group_by(medals, &#x26;(&#x26;1.medal), &#x26;(&#x26;1.player))\n# %{bronze: [\"Anna\"], gold: [\"Anna\", \"Zoe\"], silver: [\"Joe\", \"Anderson\", \"Peter\"]}\n</code></pre>\n<h3>Comprehensions</h3>\n<ul>\n<li>generator function that will assign each item to the list of variable a</li>\n</ul>\n<pre><code class=\"language-elixir\">for a &#x3C;- [\"dogs\", \"cats\", \"flowers\"], do: String.upcase(a)\nfor a &#x3C;- [\"Willy\", \"Anna\"], b &#x3C;- [\"Math\", \"English\"], do: {a,b} # combining \nparseds = for i &#x3C;- [\"10\", \"hot dogs\", \"20\"], do: Integer.parse(i) # [{10, \"\"}, :error, {20, \"\"}]\nfor {n,_} &#x3C;- parseds, do: n # [10,20]\nfor n &#x3C;- [1, 2, 3, 4, 5, 6, 7], n > 3, do: n # [4, 5, 6, 7]\n</code></pre>\n<h3>Pipelining your functions</h3>\n<pre><code class=\"language-elixir\">defmodule HigherOrderFunctions do\n  def compose(f, g) do\n    fn arg -> f.(g.(arg)) end\n  end\nend\n\nimport HigherOrderFunctions \nfirst_letter_and_upcase = compose(&#x26;String.upcase/1, &#x26;String.first/1)\nfirst_letter_and_upcase.(\"works\") # W\n\n# Using pipe and capture operators\nfirst_letter_and_upcase = &#x26;(&#x26;1 |> String.first |> String.upcase)\nfirst_letter_and_upcase.(\"works\") # W\n\ndefmodule MyString do\n  def capitalize_words(title) do\n    words = String.split(title)\n    capitalize_words = Enum.map(words, &#x26;String.capitalize/1)\n    Enum.join(capitalize_words, \" \")\n  end\nend\n\n# elixir way\ndefmodule MyString do\n  def capitalize_words(title) do\n    title\n    |> String.split\n    |> Enum.map(&#x26;String.capitalize/1)\n    |> Enum.join(\" \")\n  end\nend\n\n# with smaller functions\ndefmodule MyString do\n  def capitalize_words(title) do\n    title\n    |> String.split()\n    |> capitalize_all\n    |> join_with_whitespace\n  end\n\n  def capitalize_all(words) do\n    Enum.map(words, &#x26;String.capitalize/1)\n  end\n\n  def join_with_whitespace(words) do\n    Enum.join(words, \" \")\n  end\nend\n\nMyString.capitalize_words(\"a whole new world\") # \"A Whole New World\"\n</code></pre>\n<h3>Partial Application</h3>\n<pre><code class=\"language-elixir\">defmodule WordBuilder do\n  def build(alphabet, positions) do\n    partial = fn at -> String.at(alphabet, at) end\n    letters = Enum.map(positions, partial)\n    Enum.join(letters)\n  end\nend\n\n# refactored with function capturing\ndefmodule WordBuilder do\n  def build(alphabet, positions) do\n    letters = Enum.map(positions, &#x26;String.at(alphabet, &#x26;1))\n    Enum.join(letters)\n  end\nend\n\nWordBuilder.build(\"world\", [4, 1, 1, 2]) # \"door\"\n</code></pre>\n<h3>Infinite data</h3>\n<ul>\n<li>streams have no end</li>\n</ul>\n<pre><code class=\"language-elixir\">range = 1..10\nEnum.each(range, &#x26;IO.puts/1) # prints each\n\ndefmodule FactorialV2 do\n  def of(0), do: 1\n\n  def of(n) when n > 0 do\n    1..10_000_000\n    |> Enum.take(n)\n    |> Enum.reduce(&#x26;(&#x26;1 * &#x26;2))\n  end\nend\n\ndefmodule FactorialV2 do\n  def of(0), do: 1\n\n  def of(n) when n > 0 do\n    Stream.iterate(1, &#x26;(&#x26;1 + 1))\n    |> Enum.take(n)\n    |> Enum.reduce(&#x26;(&#x26;1 * &#x26;2))\n  end\nend\n\n\nFactorialV2.of(10000)\nintegers = Stream.iterate(1, fn previous -> previous + 1 end)\nEnum.take(integers, 5)\n\ndefmodule Halloween do\n  def give_candy(kids) do\n    ~w(chocolate jelly mint)\n    |> Stream.cycle()\n    |> Enum.zip(kids)\n  end\nend\n\nHalloween.give_candy(~w(Mika Anna Ted Mary Alex Emma))\n</code></pre>\n<h3>Eager/Lazy</h3>\n<pre><code class=\"language-elixir\"># slow, eager\ndefmodule ScrewsFactory do\n  def run(pieces) do\n    pieces\n    |> Enum.map(&#x26;add_thread/1)\n    |> Enum.map(&#x26;add_head/1)\n    |> Enum.each(&#x26;output/1)\n  end\n\n  defp add_thread(piece) do\n    Process.sleep(50)\n    piece &#x3C;> \"--\"\n  end\n\n  defp add_head(piece) do\n    Process.sleep(100)\n    \"o\" &#x3C;> piece\n  end\n\n  defp output(screw) do\n    IO.inspect(screw)\n  end\nend\nmetal_pieces = Enum.take(Stream.cycle([\"-\"]), 100)\nScrewsFactory.run(metal_pieces)\n\n# lazy\ndefmodule ScrewsFactory do\n  def run(pieces) do\n    pieces\n    |> Stream.map(&#x26;add_thread/1)\n    |> Stream.map(&#x26;add_head/1)\n    |> Enum.each(&#x26;output/1)\n  end\n\n  defp add_thread(piece) do\n    Process.sleep(50)\n    piece &#x3C;> \"--\"\n  end\n\n  defp add_head(piece) do\n    Process.sleep(100)\n    \"o\" &#x3C;> piece\n  end\n\n  defp output(screw) do\n    IO.inspect(screw)\n  end\nend\n\n# very fast stream\ndefmodule ScrewsFactory do\n  def run(pieces) do\n    pieces\n    |> Stream.chunk(50)\n    |> Stream.flat_map(&#x26;add_thread/1)\n    |> Stream.chunk(100)\n    |> Stream.flat_map(&#x26;add_head/1)\n    |> Enum.each(&#x26;output/1)\n  end\n\n  defp add_thread(pieces) do\n    Process.sleep(50)\n    Enum.map(pieces, &#x26;(&#x26;1 &#x3C;> \"--\"))\n  end\n\n  defp add_head(pieces) do\n    Process.sleep(100)\n    Enum.map(pieces, &#x26;(\"o\" &#x3C;> &#x26;1))\n  end\n\n  defp output(screw) do\n    IO.inspect(screw)\n  end\nend\n</code></pre>\n<ul>\n<li>creating chunks and flat_map creates a queue before processing</li>\n</ul>\n<h2>Application</h2>\n<ul>\n<li>mix is a built in CLI for generating a project structure</li>\n</ul>\n<pre><code class=\"language-bash\">mix new app_name\n</code></pre>\n<p><code>use ExUnit.Case</code> adds new capabilities to the current module, mostly with metaprogramming</p>\n<pre><code class=\"language-elixir\">defmodule DungeonCrawl do\n  @moduledoc \"\"\"\n  Documentation for `DungeonCrawl`.\n  \"\"\"\n\n  @doc \"\"\"\n  Hello world.\n\n  ## Examples\n\n      iex> DungeonCrawl.hello()\n      :world\n\n  \"\"\"\n  def hello do\n    :world\n  end\nend\n</code></pre>\n<ul>\n<li>This example is run as test, to ensure the doc examples work</li>\n<li><a href=\"https://hexdocs.pm/ex_unit/ExUnit.html\">Exunit Docs</a></li>\n</ul>\n<p><code>mix new</code> and <code>mix test</code> are tasks. You can add custom tasks</p>\n<ul>\n<li><a href=\"https://hexdocs.pm/mix/Mix.Task.html\">Mix.Taak doc</a></li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule Mix.Tasks.Start do\n  use Mix.Task\n\n  def run(_), do: IO.puts(\"Hello, World!\")\nend\nmix start # Hello, World!\niex -S mix # load the module\n</code></pre>\n<p><code>alias DungeonCrawl.Character</code> allows to reference <code>%Character</code></p>\n<h2>Protocol</h2>\n<ul>\n<li>create a single interface that works on different data types</li>\n<li>polymorphic</li>\n<li><a href=\"http://elixir-lang.org/getting-started/protocols.html\">protocol doc</a></li>\n<li>if you own the struct, put the implementation in the same file as the struct</li>\n<li>if you don't own the struct, but own the protocol, put the implementation inside the protocol file</li>\n<li>if you own neither the struct or the protocol, create a file, with the protocol name and put the implementation there</li>\n<li>great for structs but not for simple modules</li>\n</ul>\n<pre><code class=\"language-elixir\">defprotocol DungeonCrawl.Display do\n  def info(value)\nend\n\ndefimpl DungeonCrawl.Display, for: DungeonCrawl.Room.Action do\n  def info(action), do: action.label\nend\n\ndefimpl DungeonCrawl.Display, for: DungeonCrawl.Character do\n  def info(character), do: character.name\nend\n\n</code></pre>\n<h2>Module Behaviors</h2>\n<ul>\n<li>a behavior is a contract between a module and the client code tht is using it</li>\n<li>common interface across multiple modules</li>\n</ul>\n<pre><code class=\"language-elixir\">defmodule DungeonCrawl.Room.Trigger do\n  @callback run(character :: any, action :: any) :: any\nend\n\ndefmodule DungeonCrawl.Room.Triggers.Exit do\n  @behaviour DungeonCrawl.Room.Trigger\n  def run(character, _), do: {character, :exit}\nend\n\n</code></pre>\n<p><strong>Protocols vs Behaviors</strong> Protocols work with structs, and behaviors work with modules. Protocols create a function interface to work with several data types. Behaviors define a list of functions that a module should implement.</p>\n<h2>Control flow of impure functions</h2>\n<ol>\n<li>First strategy is pattern matching.</li>\n<li>Use case, if or function clauses to handle impure function results</li>\n</ol>\n<p>example control flow with matching</p>\n<pre><code class=\"language-elixir\">defmodule Other.Shop do\n  def checkout() do\n    quantity = ask_number(\"Quantity?\")\n    price = ask_number(\"Price?\")\n    calculate(quantity, price)\n  end\n\n  def calculate(:error, _), do: IO.puts(\"Quantity is not a number\")\n  def calculate(_, :error), do: IO.puts(\"Price is not a number\")\n  def calculate({quantity, _}, {price, _}), do: quantity * price\n\n  def ask_number(message) do\n    (message &#x3C;> \"\\n\")\n    |> IO.gets()\n    |> Integer.parse()\n  end\nend\n</code></pre>\n<p>case</p>\n<pre><code class=\"language-elixir\">  def ask_for_index(options) do\n    answer =\n      options\n      |> display_options()\n      |> generate_question()\n      |> Shell.prompt()\n      |> Integer.parse()\n\n    case answer do\n      :error ->\n        display_invalid_option()\n        ask_for_index(options)\n\n      {option, _} ->\n        option - 1\n    end\n  end\n</code></pre>\n<h3>try/catch/raise/rescue</h3>\n<ul>\n<li>try wraps a code block, if an error is raised you can use rescue to recover</li>\n<li>you can capture values in catch</li>\n<li>throwing values or raising errors is unusual in FP</li>\n<li>You can identify functions that raise errors because the name has <code>!</code></li>\n<li>MatchError is too generic to rescue</li>\n<li><a href=\"https://hexdocs.pm/elixir/Kernel.html#defexception/1\">Exception Doc</a></li>\n<li>elixir devs prefer raise/rescue due to lack of clarity and increased complexity</li>\n</ul>\n<p>The difference between throw/catch and raise/rescue is that try/catch doesn't necessarily mean an error.\nIt will stop the function from throwing a value that must be caught, like control-flow structures.</p>\n<p>raise/rescue</p>\n<pre><code class=\"language-elixir\">def ask_for_option(options) do\n    try do\n        options\n        |> display_options()\n        |> generate_question()\n        |> Shell.prompt()\n        |> parse_answer!()\n        |> find_option_by_index!(options)\n\n    rescue\n      e in DungeonCrawl.CLI.InvalidOption ->\n        display_error(e)\n        ask_for_option(options)\n    end\nend\n</code></pre>\n<p>try/catch</p>\n<pre><code class=\"language-elixir\">def ask_for_option(options) do\n    try do\n        options\n        |> display_options()\n        |> generate_question()\n        |> Shell.prompt()\n        |> parse_answer!()\n        |> find_option_by_index!(options)\n    catch\n        {:error, message} ->\n        display_error(message)\n        ask_for_option(options)\n    end\nend\n\n# if you only need one try block you can omit try do\ndef ask_for_option(options) do\n    options\n    |> display_options()\n    |> generate_question()\n    |> Shell.prompt()\n    |> parse_answer!()\n    |> find_option_by_index!(options)\n    catch\n        {:error, message} ->\n        display_error(message)\n        ask_for_option(options)\n    end\nend\n</code></pre>\n<h2>Handling impure functions with the Error Monad</h2>\n<ul>\n<li>Use when you have many functions in sequence and some can fail</li>\n<li><strong>monad</strong> wraps a value with properties to give more information about that value, i.e. context</li>\n<li>Error monad has automatic skipping of function executions if the value has an error to handle in a central point</li>\n<li>To make it work, you need a bind function, bind knows how to combine the function and value</li>\n<li>Many libraries available: <a href=\"https://github.com/rmies/monad\">monad</a>, <a href=\"https://github.com/CyrusOfEden/towel\">towel</a>, <a href=\"https://github.com/witchcrafters/witchcraft\">witchcraft</a> and <a href=\"https://github.com/rob-brown/MonadEx\">MonadEx</a></li>\n</ul>\n<pre><code class=\"language-elixir\">use Monad.Operators\nimport Monad.Result\nsuccess(42) ~>> (&#x26; &#x26;1 + 1) ~>> (&#x26; &#x26;1 + 2) # 45\nerror(\"wrong\") ~>> (&#x26; &#x26;1 + 1) ~>> (&#x26; &#x26;1 + 2) # Monad.Result{type: :error, value: nil, error: \"wrong\"}\n</code></pre>\n<ul>\n<li><code>~>></code> is the bind operator, left side expects a monad and the right expects a function. It executes values in success and skips in error context.</li>\n</ul>\n<pre><code class=\"language-elixir\">  def ask_for_option(options) do\n    result =\n      return(options)\n      ~>> (&#x26;display_options/1)\n      ~>> (&#x26;generate_question/1)\n      ~>> (&#x26;Shell.prompt/1)\n      ~>> (&#x26;parse_answer/1)\n      ~>> (&#x26;find_option_by_index(&#x26;1, options))\n\n    if success?(result) do\n      result.value\n    else\n      display_error(result.error)\n      ask_for_option(options)\n    end\n  end\n</code></pre>\n<h2>With</h2>\n<ul>\n<li>combine multiple match clauses</li>\n<li>if all the clauses match run do, else code stops and return non-matching</li>\n<li>you should use with if you have function pipelines that can result in an errors</li>\n</ul>\n<pre><code class=\"language-elixir\"># before\ndef checkout() do\n    try do\n        {quantity, _} = ask_number(\"Quantity?\")\n        {price, _} = ask_number(\"Price?\")\n        calculate(quantity, price)\n    rescue\n        MatchError -> \"It's not a number\"\n    end\nend\n\n\ndef checkout() do\n    result = with {quantity, _} &#x3C;- ask_number(\"Quantity?\"), {price, _} &#x3C;- ask_number(\"Price?\") do\n        calculate(quantity, price)\n    end\n\n    if result == :error, do: IO.puts(\"It's not a number\"), else: result\nend\n\n# alternative with else\ndef checkout() do\n    with {quantity, _} &#x3C;- ask_number(\"Quantity?\"), {price, _} &#x3C;- ask_number(\"Price?\") do\n      calculate(quantity, price)\n    else\n      :error -> IO.puts(\"It's not a number\")\n    end\nend\n</code></pre>\n<ul>\n<li><code>&#x3C;-</code> will execute block on the right side and pattern match the left</li>\n</ul>","frontmatter":{"date":"March 26, 2023","title":"Elixir","tags":["language"]}}},"pageContext":{"slug":"/elixir/"}},
    "staticQueryHashes": ["1929983096","3649515864"]}